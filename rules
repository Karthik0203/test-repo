<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sailpoint PUBLIC "sailpoint.dtd" "sailpoint.dtd">
<sailpoint>
<Rule language="beanshell" name="Dummy">
  <Source>
import sailpoint.object.Identity;
import org.apache.commons.logging.LogFactory;
import org.apache.commons.logging.Log;

  Log log = LogFactory.getLog("Rahul.logs");
   
  Identity user = context.getObjectByName(Identity.class,"Aaron.Nichols");
  
  log.debug("FN: " +user.getFirstname());
  
  
 
</Source>
</Rule>
<Rule language="beanshell" name="Example - Walk Identities">
  <Description>Example Rule - Identity Description</Description>
  <Source>

    import java.util.List;
    import java.util.Iterator;
    import sailpoint.object.*;

    String delimiter = "|";


  Identity user = context.getObjectByName(Identity.class,"Aaron.Nichols");

  System.out.println("\n\n\nIdentity Info for Aaron.Nichols");
  System.out.println("========================");
  System.out.println("Email Address = " + user.getEmail());
  System.out.println("Status = " + user.getAttribute("status"));
  System.out.println("Location = " + user.getAttribute("location"));
  System.out.println("Region = " + user.getAttribute("region"));

System.out.println("\nListing of Accounts");

  List Links= (List) user.getLinks();

 if (null != Links) {
        Iterator linkIterator = Links.iterator();
        while (linkIterator.hasNext()) {
            Link account = (Link) linkIterator.next();
            System.out.println("Application Name = " + account.getApplicationName() + ";Account Name = " + account.getDisplayableName());
    }
}




  System.out.println("\nListing of Detected Roles");

  List Bundles = (List) user.getBundles();

 if (null != Bundles) {
        Iterator bundleIterator = Bundles.iterator();
        while (bundleIterator.hasNext()) {
            Bundle role = (Bundle) bundleIterator.next();
            System.out.println("Role Name = " + role.getFullName() + ";Role Type = " + role.getType());
    }
}

 System.out.println("\nListing of Assigned Roles");

 Bundles = (List) user.getAssignedRoles();

 if (null != Bundles) {
        Iterator bundleIterator = Bundles.iterator();
        while (bundleIterator.hasNext()) {
            Bundle role = (Bundle) bundleIterator.next();
            System.out.println("Role Name = " + role.getFullName() + ";Role Type = " + role.getType());
    }
}

  
  </Source>
</Rule>
<Rule language="beanshell" name="Creation Rule - Set DisplayName" type="IdentityCreation">
  <Description>Identity creation rules are used to set attributes on new Identity objects when they are created.  New identities may be created during the aggregation of application accounts, or optionally created after pass-through authentication.

One common operation is to change the name property of the identity when the default application name is complex (such as a directory DN).

Another common operation is to assign a set of initial capabilities based on the attributes pulled from the application account.</Description>
  <Signature returnType="void">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="environment" type="Map">
        <Description>
          Arguments passed to the aggregation task.
        </Description>
      </Argument>
      <Argument name="application">
        <Description>
          Application being aggregated.
        </Description>
      </Argument>
      <Argument name="account" type="ResourceObject">
        <Description>
          The resource account for the identity being created.
        </Description>
      </Argument>
      <Argument name="identity" type="Identity">
        <Description>
          The identity that is being created.
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>import sailpoint.object.Identity;
import org.apache.commons.logging.LogFactory;
import org.apache.commons.logging.Log;

  Log log = LogFactory.getLog("Rahul.logs");
   
  String firstName = account.getAttribute("FIRST_NAME");
  String lastName = account.getAttribute("LAST_NAME");
  
  String displayName = firstName +"."+ lastName;
 
  identity.setName(displayName);

  log.debug("Display Name" + displayName);</Source>
</Rule>
<Rule language="beanshell" name="No Correlator" type="Correlation"/>
<Rule language="beanshell" name="Clear CustomGlobal">
  <Source>
      
        import sailpoint.object.CustomGlobal;

        List results = new ArrayList();
        results.add("CustomGlobal BEFORE clear had ["+
                    CustomGlobal.size() + "] keys.");
        CustomGlobal.clear();
        results.add("CustomGlobal AFTER clear has [" +
                   CustomGlobal.size()+"] keys.");

        return results;
      
    </Source>
</Rule>
<Rule language="beanshell" name="IdentityNowSAML" type="SAMLCorrelation">
  <Signature>
    <Inputs>
      <Argument name="log">
        <Description>
                    Logger to take care of logging.
                </Description>
      </Argument>
      <Argument name="context">
        <Description>
                    SailPointContext
                </Description>
      </Argument>
      <Argument name="assertionAttributes">
        <Description>
                    Map of attributes taken from the SAML assertion
                </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="ident">
        <Description>
                    Matching identity based on the nameId taken from assertionAttributes
                </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
        
            // Imports
            import sailpoint.object.Identity;

            // Making a BIG assumption here that the nameid-format is unspecified/persitent

            // Get the nameId from the assertionAttributes
            String nameId = (String)assertionAttributes.get("nameId");

            Identity ident;

            if(nameId != null) {
                // Lookup the identity based on nameId
                ident = context.getObject(Identity.class, nameId);
            }

            return ident;

        
    </Source>
</Rule>
<Rule language="beanshell" name="Workflow Library">
  <Source>
    
      import sailpoint.object.Filter;
      import sailpoint.object.Identity;
      import sailpoint.object.ProvisioningPlan;
      import sailpoint.object.ProvisioningPlan.AccountRequest;
      import sailpoint.object.ProvisioningPlan.AttributeRequest;
      import sailpoint.object.QueryOptions;
      import sailpoint.tools.Util;

      boolean otob(Object o) { return Util.otob(o); }
      boolean isTrue(Object o) {otob(o); } 
      boolean isFalse(Object o) {!otob(o); }
      boolean isNull(Object o) {o == null; } 
      int size(Collection o) { return Util.size(o); }
      String toString(Object o) {(o == null) ? "*null*" : o.toString(); }
      void println(Object o) {System.out.println(o); }
      void print(String str) { System.out.print(str); }
      void printval(String n, Object o) {println(n + " = " + toString(o)); }


      public List csvToList(String csv) {
        return Util.csvToList(csv);
      }

      /** 
       * resolve displayName by doing a projection query.
       */ 
      public String resolveDisplayName(String identityName) {
          String displayName = getIdentityProperty(identityName, "displayName"); 
          if ( displayName == null ) {
              displayName = identityName;
          }
          return displayName;
      }
      
      /** 
       * If the identityDisplayName is null resolve it by doing
       * a projection query.
       */ 
      public String resolveDisplayName(String identityName, String currentDisplayName) {
          // allow it to be passed in to avoid the query
          String displayName = null;
          if ( currentDisplayName != void ) {
              displayName = currentDisplayName;
          }
          if ( displayName == null ) {
              displayName = resolveDisplayName(identityName);
          }
          return displayName;
      }

      /**
       * Given an Identity's name, return the email address.
       */
      public String getEmail(String name) {
          return getIdentityProperty(name, "email");
      }

      /**
       * Given an Identity's name and a ProvisioningPlan, return the email address.
       * This can be used for user notifications when a request to create an
       * identity was rejected.  In this case there will not be an identity in
       * the database, so we will try to extract the email address from the plan.
       */
      public String getUserEmail(String name, ProvisioningPlan plan) {
          String email = getEmail(name);

          if (null == email) {
              email = getIIQCreateRequestValue(plan, "email");
          }

          return email;
      }

      /**
       * Given an Identity's name, return the manager's email address.
       */
      public String getManagersEmail(String name) {
          return getIdentityProperty(name, "manager.email"); 
      }

      /**
       * Given an Identity's name, return the manager's email address.
       * This can be used for user notifications when a request to create an
       * identity was rejected.  In this case there will not be an identity in
       * the database, so we will try to extract the manager from the plan to
       * lookup the email address.
       */
      public String getManagersEmail(String name, ProvisioningPlan plan) {
          String email = getManagersEmail(name);

          if (null == email) {
              String manager = getIIQCreateRequestValue(plan, "manager");
              if (null != manager) {
                  Identity identity = context.getObject(Identity.class, manager);
                  if (null != identity) {
                      email = identity.getEmail();
                  }
              }
          }

          return email;
      }

      /**
       * Return the value for the requested attribute from the ProvisioningPlan
       * if this is an identity creation request.
       */
      private String getIIQCreateRequestValue(ProvisioningPlan plan, String attr) {
          String value = null;

          if (null != plan) {
              AccountRequest acctReq = plan.getIIQAccountRequest();
              if ((null != acctReq) &amp;&amp;
                  AccountRequest.Operation.Create.equals(acctReq.getOperation())) {
                  AttributeRequest attrReq = acctReq.getAttributeRequest(attr);
                  if (null != attrReq) {
                      value = (String) attrReq.getValue();
                  }
              }
          }

          return value;
      }

      /** 
       * Return a single string property value from an identity.
       */
      public String getIdentityProperty(String identity, String property) {
          QueryOptions ops = new QueryOptions();
          Filter nameFilter = Filter.eq("name", identity);
          ops.add(new Filter[]{nameFilter});

          String val = null; 
          Iterator it = context.search(Identity.class, ops, property);
          while ( it.hasNext() ) {
              Object[] row = (Object[])it.next();
              val = (String)row[0];
              if ( it.hasNext() ) {
                  // shouldn't happen but guard
                  throw new GeneralException("More then one ["+property+"] value returned for ["+identity+"]");
              }
          } 
          return val;
      }

      /**
       * Return the value of a system configuration property.
       * The value is always returned as a string.
       */
      public String getConfiguration(String name) {
          return context.getConfiguration().getString(name);
      }

    
  </Source>
</Rule>
<Rule language="beanshell" name="Approval Library">
  <Source>
    

    import sailpoint.api.ManagedAttributer;
    import sailpoint.object.Application;
    import sailpoint.object.ApprovalSet;
    import sailpoint.object.ApprovalItem;
    import sailpoint.object.AttributeDefinition;
    import sailpoint.object.Attributes;
    import sailpoint.object.Bundle;
    import sailpoint.object.Identity;
    import sailpoint.object.ManagedAttribute;
    import sailpoint.object.ProvisioningPlan;
    import sailpoint.object.ProvisioningPlan.AccountRequest;
    import sailpoint.object.ProvisioningPlan.AttributeRequest;
    import sailpoint.object.ProvisioningPlan.PermissionRequest;
    import sailpoint.object.ProvisioningPlan.GenericRequest;
    import sailpoint.object.ProvisioningProject;
    import sailpoint.object.Scope;
    import sailpoint.object.WorkItem;
    import sailpoint.object.Workflow;
    import sailpoint.object.Workflow.Approval;
    import sailpoint.tools.Util;
    import sailpoint.tools.xml.XMLObjectFactory;
    
    /** 
    * Take a list of AttributeRequests and return a List of Attributes
    * to store on the approval item so that we can get at the attributes of
    * each attribute request in case we need information about that attribute request
    */
    public Attributes getAttributeRequestArguments(List attributeRequests) {
      Attributes attributes = new Attributes();
      for(AttributeRequest attr : attributeRequests) {
        String key = attr.getName()+":"+attr.getValue();
        Attributes arguments = attr.getArguments();
        attributes.put(key, arguments);
      }
      return attributes;
    }

    /**
     * Turn a list of AttributeRequests into simple
     * name = 'value' format. Represent this as a list
     * so we can display it neatly in the ui tier and
     * still not mess with dn strings.
     *
     * A general utility method used both by rules and workflow
     * scripts.  
     */
    public List flattenAttributeRequests(List attributeRequests) {
        List flat = new ArrayList();
        flattenAttributeRequests(attributeRequests, flat);
        return flat;
    }
    
    /**
    *  Bug 15833, ensure requester comments make it into manual actions
    */
    public String getRequesterComments(List requests) {
        String comment = "";
        if(requests != null) {
            for(GenericRequest request : requests) {
                String innerComment = request.getComments();
                if ( Util.getString(innerComment) != null ) {
                    comment += innerComment;
                }
            }
        }
        return comment;
    }
        
    public void flattenAttributeRequests(List attributeRequests, List flat) {
        if ( Util.size(attributeRequests) &gt; 0 ) {
            for (AttributeRequest attr : attributeRequests ) {
                if( !attr.getName().equals(ProvisioningPlan.ATT_IIQ_PASSWORD) &amp;&amp;
                    !attr.getBoolean(ProvisioningPlan.ARG_SECRET) &amp;&amp;
                    !attr.getName().equals(Identity.PRF_USE_BY_DATE)) {
                    if (attr.getDisplayValue() == null) {
                        String displayName = attr.getName();
                        List val = Util.asList(attr.getValue());
                        if ( val != null ) {
                            if ( attr.getName().equals("manager") ) { 
                                String managerName = null;
                                if ( Util.size(val) == 1 ) {
                                    // For manager convert the name into a displayName so it looks 
                                    // reasonable in the ui
                                    managerName = (String)val.get(0);
                                    if ( manager != null ) {
                                        String displayName = getIdentityProperty(managerName, "displayName");
                                        if ( displayName != null ) {
                                            val = Util.csvToList(displayName);
                                        }
                                    }
                                }
                            }
                            
                            String type = (String)attr.get(ProvisioningPlan.ARG_TYPE);
                            if (type!=null &amp;&amp; type.equals(ProvisioningPlan.ARG_TYPE_DATE)) {
                              Object obj = val.get(0);
                              
                              Date date = null;
                              
                              if(obj instanceof java.util.Date) {
                                date = obj;
                              } else {
                                date = new Date((Long)obj);
                              }
                              val = new ArrayList();                         
                              val.add(Util.dateToString(date, "M/d/y"));
                            } else if (AttributeDefinition.TYPE_SCOPE.equals(type)) {
                              val = getScopeNames(val);  
                            }
                            
                        }
                        if ( Util.size(val) &gt; 0 ) 
                            flat.add(displayName+ " = '"+Util.listToCsv(val)+"'");
                    } else {
                        flat.add(attr.getDisplayValue());
                    }
                }
            }
        }
    }
    
    /*
     * Given a list of scope ids it will return a list of 
     * scope names.
     *
     */
    public List getScopeNames(List val) {
        
        if (val == null) {
            return null;
        }

        List scopeNames = new ArrayList();
        for (int i=0; i&lt;val.size(); ++i) {
            scopeNames.add(fetchScopeName((String) val.get(i)));
        }
        
        return scopeNames;
    }

    /**
     * Fetches a scope name from scope id
     *
     */    
    private String fetchScopeName(String id) {
        
        Scope scope =  context.getObjectById(Scope.class, id);
        
        if (scope == null) {
            return null;
        }
        
        return scope.getDisplayableName();
    }

    /**
     * Convert a List&lt;PermissionRequests&gt; into a List&lt;String&gt;
     * with each string formatted as "target='right,right,right'"
     * This is similar to flattenAttributeRequests above but 
     * kept distinct in case we need to change the rendering of permissions.
     * Currently it's ambiguous whether this is an attribute or a permission
     */
    public void flattenPermissionRequests(List permRequests, List flat) {

        if (permRequests != null) {
            for (PermissionRequest perm : permRequests ) {

              // we dont' have display names for targets, do we?
              flat.add(perm.getTarget() + " = '" + perm.getRights() + "'");
            }
        }
    }

    /**
     * Convert a Map&lt;String,ApprovalSet&gt; into Approval objects. 
     * One Approval object for each of the keys in the map.
     *
     * Used only by rules that calculate approval structures such
     * as LCM Build Owner Approvals.
     *
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    public List buildApprovalsFromMap(Map ownerToSet, String identityName, String launcher) {
        List approvals = new ArrayList();
        if ( ownerToSet == null ) 
            return null;

        Iterator keys = null;
        Set keySet = ownerToSet.keySet();
        if ( keySet != null )  
            keys = keySet.iterator();

        if ( keys != null ) {
            while ( keys.hasNext() ) {
                String key = (String)keys.next();
                if ( key == null ) continue;
                ApprovalSet set = ownerToSet.get(key);
                if ( set != null ) {
                    if ( log.isDebugEnabled() ) {
                        log.debug("Owner["+key+"] " + set.toXml());
                    }
                    // djs: check here to make sure this isn't an auto-approved 
                    // item because the approver is the launcher
                    if ( !sailpoint.workflow.IdentityLibrary.isElectronicSignatureEnabled(wfcontext) &amp;&amp; 
                         key.compareTo(launcher) == 0 &amp;&amp; 
                         set.isAllApproved() ) {
                        // self approved continue;
                        continue;
                    } else {
                        Approval newApproval = new Approval();
                        newApproval.setOwner("\"" + key + "\"");  // quote the owner in case the user name has a comma
                        newApproval.setApprovalSet(set);
                        newApproval.addArg(Workflow.ARG_WORK_ITEM_TARGET_CLASS, "sailpoint.object.Identity");
                        newApproval.addArg(Workflow.ARG_WORK_ITEM_TARGET_NAME, identityName);
                        approvals.add(newApproval);
                    } 
                }
            }
        }
        if ( log.isDebugEnabled() ) {
            if ( approvals != null )
                log.debug("Approvals: " + XMLObjectFactory.getInstance().toXml(approvals));
            else
                log.debug("Approvals EMPTY.");
        }
        return approvals;
    }

    /**
     * Build a Map&lt;String,ApprovalSet&gt; each key representing a unique owner.
     * Use a Map here to allow us to easily merge any items for the same owner.
     *
     * Used by rules to build approval structures, normally followed by
     * a call to buildApprovalsFromMap.
     * 
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    public Map buildOwnerMap(String scheme, ApprovalSet approvalSet, 
                             ProvisioningPlan plan, String fallbackApprover, 
                             String identity, boolean autoApprove) {

        // djs: use a LinkedHashMap here to perserve the order of the
        // approvers in the list.  This is important for manager transfer
        // approvals.
        Map ownerToSet = new LinkedHashMap();
        List items = approvalSet.getItems();
        for ( ApprovalItem item : items ) {
            List approvers = getApproverNames(scheme, item, plan, identity);
            if ( approvers != null &amp;&amp; approvers.size() == 0 &amp;&amp; fallbackApprover != null ) {
                if ( log.isDebugEnabled() ) {
                    log.debug("Approver could not be resolved using fallbackApprover '"+fallbackApprover+"'.");
                }
                approvers.add(fallbackApprover);
            }
            //
            // Build an approval set or add an ApprovalItem 
            // to an existing set
            //
            if ( Util.size(approvers) &gt; 0 ) {
                for ( String approver : approvers ) {
                    ApprovalSet set = (ApprovalSet)ownerToSet.get(approver);
                    if ( set == null ) {
                        set = new ApprovalSet();
                    }

                    // Make a copy of the item here so they are independent of the the
                    // cart's item.  
                    ApprovalItem itemCopy = XMLObjectFactory.getInstance().clone(item, context);
                    set.add(itemCopy);
                    ownerToSet.put(approver, set);
                    if ( autoApprove ) {
                        // djs: when we come across the launcher who is also the approver
                        // auto approve the item, this will allow us to audit/report on
                        // the request but not force an approval.  We won't create an 
                        // Approval object if all of the items are acccepted
                        if ( approver.equals(launcher) ) {
                            itemCopy.setState(WorkItem.State.Finished);
                            if ( log.isDebugEnabled() ) {
                                log.debug("Launcher was also approver and was removed.");
                            }
                            // If there is just one approver AND we are marking this 
                            // Auto-Approved also mark the master approvalSets item 
                            // finished
                            if ( approvers.size() == 1 ) {
                                item.setState(WorkItem.State.Finished);
                            }
                        }
                    }
                }
                //
                // Update the "cart" representation
                //
                // set the item's owner so we have an update
                // version in the "registry"
                // Should we store a csv Multiple approvers ?
                item.setOwner(approvers.get(0));
            }
        }
        if ( log.isDebugEnabled() ) {
            if ( ownerToSet != null )
                log.debug("OwnerSetMap: " + XMLObjectFactory.getInstance().toXml(ownerToSet));
            else
                log.debug("OwnerSetMap EMPTY.");
        }
        return ownerToSet;
    }

    /**
     * Return a list of names that represent the names of the Identities that should
     * approve the item.  We need the Plan during manager transfers when we need to figure
     * out what the new value is for the manager attribute.
     *
     * Only time the returned list is null is when we have "none"
     * approval scheme.
     *
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    public List getApproverNames(String scheme, ApprovalItem item, ProvisioningPlan plan, String identity) {
        return getApproverNames(scheme, item, plan, identity, null);
    }

    /**
     * Return a list of names that represent the names of the Identities that should
     * approve the item.  We need the Plan during manager transfers when we need to figure
     * out what the new value is for the manager attribute.
     *
     * Only time the returned list is null is when we have "none"
     * approval scheme.
     *
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    public List getApproverNames(String scheme, ApprovalItem item, ProvisioningPlan plan,
                                 String identity, String securityOfficerName) { 

        List owners = new ArrayList();
        String schemeToUse = scheme;
        if ( schemeToUse == null ) {
            schemeToUse = "manager";
            log.warn("Approval Scheme was not defined defaulting to manager.");
        }
        List schemes = Util.csvToList(schemeToUse);

        // None will short-circuit and cause no approvals.
        if ( schemes.contains("none") ) {
            return null;
        } 

        if ( ( schemes.contains("manager") ) || ( schemes.contains("newManager") ) ) {
            List managers = getManagers(schemes, plan, identity);
            if ( null != managers ) { 
                owners.addAll(managers);
            } 
        }

        if ( schemes.contains("owner") ) {
            String app = item.getApplication(); 
            String op = item.getOperation();
            if ( ProvisioningPlan.APP_IIQ.compareTo(app) == 0 ) { 
                if ( ( ProvisioningPlan.Operation.Add.toString().equals(op) ) || 
                     ( ProvisioningPlan.Operation.Remove.toString().equals(op) ) ) {
                    // this is a role requst, entitlement request or identity update
                    if ( ( ProvisioningPlan.ATT_IIQ_DETECTED_ROLES.equals(item.getName()) ) ||
                         ( ProvisioningPlan.ATT_IIQ_ASSIGNED_ROLES.equals(item.getName()) ) ) {
                        String owner = resolveRoleOwner(item);
                        if ( owner != null ) owners.add(owner);
                    } 
                }
           } else {
               String owner = resolveAppRequestOwner(item);
               if ( owner != null ) 
                  owners.add(owner);
           }
        }

        if ( schemes.contains("securityOfficer") ) {
            if (null == securityOfficerName) {
                log.warn("Security officer approval is configured but securityOfficerName is not defined.");
            }
            else {
                // Only use the security officer if it is a real identity.
                Identity officer = context.getObjectByName(Identity.class, securityOfficerName);
                if (null == officer) {
                    log.warn("Could not find securityOfficer: " + securityOfficerName);
                }
                else {
                    owners.add(securityOfficerName);
                }
            }
        }

        return owners;
    }

    /**
     * Helper for getApproverNames.
     * From the item figure out the owner that should be assigned
     * to this application request.
     *
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    private String resolveAppRequestOwner(ApprovalItem item) {
        String approverName = null;

        String appName = item.getApplication();
        if ( appName == null ) return null;

        Application application = context.getObjectByName(Application.class, appName);
        if ( application == null ) 
            throw new Exception("Couldn't find application ["+appName+"]");

        Identity owner = application.getOwner();
        if ( owner != null ) {
            approverName = owner.getName();
        } else {
            // unable to find owner for application foo...
            log.debug("Unable to find owner for application ["+appName+"]");
        }

        // Check the attributeName and value and check to see if we are dealing with 
        // a ManagedAttribute 
        String attrName = item.getName();
        List vals = item.getValueList();
        if ( ( attrName != null ) &amp;&amp; ( Util.size(vals) &gt; 0 ) ) {
            // there should just be one value in each record... 
            // log something
            String val = (String)vals.get(0);
            String maOwner = getManagedAttributeOwner(application, attrName, val);
            if ( maOwner == null) {
                log.debug("Managed Attribute owner not found.. falling back to app owner.");
            } else {
                approverName = maOwner;
            }
        }
        return approverName;
    }

    /**
     * Helper for resolveAppRequestOwner.
     * Use the ManagedAttributer to find the managed attribute and get the
     * owner from the ManagedAttribute.
     *
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    private String getManagedAttributeOwner(Application app, String name, String value ) {
        String owner = null;
        ManagedAttribute ma = ManagedAttributer.get(context, app.getId(), name, value);
        if ( ma != null ) {
            Identity maOwner = ma.getOwner();
            if ( maOwner != null ) 
                owner = maOwner.getName();
        }
        return owner;
    }

    /**
     * Helper for getApproverNames.
     * If its a role request look up the role by name and get the owner
     * from the Role object.  
     *
     * TODO: should I walk up the hierarchy here if ther isn't 
     * one on the Bundle?
     *
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    private String resolveRoleOwner(ApprovalItem item) {
        String approverName = null;
        List values = item.getValueList();
        if ( Util.size(values) &gt; 0 ) {
            if ( Util.size(values) != 1 ) 
                throw new Exception("More then one value found in an approval item");

            String roleName = (String)values.get(0);
            if ( roleName != null ) {
                Bundle b = context.getObjectByName(Bundle.class, roleName);
                if ( b != null ) {
                    Identity id = b.getOwner();
                    if ( id != null ) {
                        approverName = id.getName();
                    }
                }
            }
        }
        return approverName;
    }

    /**
     * Helper for getApproverNames.
     * Get the value for manager or other by resolving the identity
     * and computing the manager, or validating the value
     * in the approvalScheme variable;
     *
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    private List getManagers(List schemes, ProvisioningPlan plan, String identity) {
        //  
        //  During Identity Creates the Identity object does not exist
        //    In this case we have to look at the plan and see if one is assigned
        //    if not assigned default to the fallbackApprover
        // 
        //  During Updates there could be one or two managers in play
        //    1) Newly assigned manager (which is still in the plan)
        //    2) Currently assigned manager ( assigned to the identity )
        //    
        List approverNames = new ArrayList();

        String currentManager = null;
        // Use the identities manager to resolve the approval
        Identity identityObject = context.getObject(Identity.class, identity);
        if ( identityObject != null ) {
            Identity manager = identityObject.getManager();
            if ( manager != null ) {
                currentManager = manager.getName();
            } else {
                log.debug("Manager not found for ["+identityObject.getName()+"] while computing approval");
            }
        }

        String planManager = resolveManagerFromPlan(plan);
        if ( ( currentManager == null ) &amp;&amp; ( planManager != null ) ) {
            // likely Identity Create case
            approverNames.add(planManager);
        } else
            if ( ( currentManager != null ) &amp;&amp; ( planManager == null ) ) {
                // normal case
                approverNames.add(currentManager);
            } else
                if ( ( currentManager != null ) &amp;&amp; ( planManager != null ) ) {
                    // Manager Transfer
                    if ( schemes.contains("manager") ){
                        approverNames.add(currentManager);
                    }
                    if ( schemes.contains("newManager") ){
                        approverNames.add(planManager);
                    } 
                }
        return ( approverNames.size() &gt; 0 ) ? approverNames : null;
    }

    /**
     * Helper for getManagers.
     * Dig into the plan and find the manager attribute for the IIQ
     * app if present. This is used during manager transfers
     * where we need to know the new manager so they can be 
     * part of the approval process.
     *
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    private String resolveManagerFromPlan(ProvisioningPlan plan )  {
        String managerName = null;
        if ( plan != null ) {
            AccountRequest iiq = plan.getAccountRequest(ProvisioningPlan.APP_IIQ);
            if ( iiq != null ) {
                AttributeRequest manager = iiq.getAttributeRequest("manager");
                if ( manager != null ) {
                    Object obj = manager.getValue();
                    if ( obj != null ) {
                        managerName = Util.getString(obj.toString());
                    }
                }
            }
        }
        return managerName;
    }

    
  </Source>
</Rule>
<Rule language="beanshell" name="Build Manual Action Approvals">
  <ReferencedRules>
    <Reference class="sailpoint.object.Rule" name="Approval Library"/>
  </ReferencedRules>
  <Source>
    
       import sailpoint.object.ApprovalSet;
       import sailpoint.object.ApprovalItem;
       import sailpoint.object.ProvisioningPlan;
       import sailpoint.object.ProvisioningPlan.AccountRequest;
       import sailpoint.service.ProvisioningTransactionService;
       import sailpoint.service.ProvisioningTransactionService.TransactionDetails;
       import sailpoint.workflow.IdentityLibrary;

       //
       // Attributes needed in the rule context: 
       //
       // project - Provisioning Project
       //
       // fallbackApprover - String representing who gets the approval
       //                    if we can't resolve one.  
       //
       // identityName - name of the identity being operated on
       //

       List approvals = null;
       ProvisioningPlan unmanaged = project.getUnmanagedPlan();
       if ( unmanaged != null ) {
           // 
           // Build an ApprovalSet from each of the things in the plan 
           // 
           Identity id = context.getObject(Identity.class, identityName);
           ApprovalSet set = new ApprovalSet();
           for ( AccountRequest acctReq : unmanaged.getAccountRequests() ) {
               ProvisioningTransactionService transService = new ProvisioningTransactionService(context);

               AccountRequest account = new AccountRequest(acctReq.toMap());
               if ( AccountRequest.Operation.Create.equals(account.getOperation()) ) {
                   ApprovalItem item = new ApprovalItem();
                   // need to deal with this 
                   item.setApplication(account.getApplication());
                   item.setInstance(account.getInstance());
                   item.setNativeIdentity(account.getNativeIdentity());
                   AccountRequest.Operation op = account.getOperation();
                   if (op == null) {
                       // shouldn't be here but assume modify
                       op = AccountRequest.Operation.Modify;
                   }
                   item.setOperation(op.toString());
                   
                   //MEH 15833, get those comments transferred to the new approval item!
                   String requesterComments = null;
                   String attrComments = getRequesterComments(account.getAttributeRequests());
                   String permComments = getRequesterComments(account.getPermissionRequests());
                   
                   //only one of these should be set... ideally
                   if(attrComments.length() &gt; 0) {
                      requesterComments = attrComments;
                   }
                   
                   if(permComments.length() &gt; 0) {
                      requesterComments = permComments;
                   }

                   if(requesterComments == null) {
                      if(account.getComments() != null) {
                         requesterComments = account.getComments();
                      }
                   }

                   item.setRequesterComments(requesterComments);

                   List reqs = new ArrayList();
                   
                   flattenAttributeRequests(account.getAttributeRequests(), reqs);
                   flattenPermissionRequests(account.getPermissionRequests(), reqs);

                   item.setValue(reqs);
                   set.add(item);
               } else {
                   // The default ApprovalSet builder creates an ApprovalItem for
                   // every attribute/permission request
                   IdentityLibrary.addApprovalItems(id, account, set);
               }

               TransactionDetails details = new TransactionDetails();
               details.setIdentityName(identityName);
               details.setProject(project);
               details.setRequest(account);
               details.setPartitionedPlan(unmanaged);
               details.setManual(true);

               if (project.getMasterPlan() != null) {
                   details.setSource(project.getMasterPlan().getSource());
               }

               transService.logTransaction(details);
           }
           // 
           // Build a map of owner to ApprovalSet from each of the items
           // in the unmanaged plan 
           // 
           // Default to the owner scheme, but we might need an option 
           // 
           Map ownerMap = buildOwnerMap("owner", set, unmanaged, fallbackApprover, identityName, false);
           if ( ownerMap != null ) {
               approvals = buildApprovalsFromMap(ownerMap, identityName, launcher);
           }
       }
       return approvals;
    
  </Source>
</Rule>
<Rule language="beanshell" name="LCM Workflow Library">
  <Source>
    
      import sailpoint.api.Provisioner;
      import sailpoint.api.SailPointFactory;
      import sailpoint.api.SailPointContext;
      import sailpoint.object.ApprovalSet;
      import sailpoint.object.ApprovalItem;
      import sailpoint.object.AuditEvent;
      import sailpoint.object.Comment;
      import sailpoint.object.Field;
      import sailpoint.object.Form;
      import sailpoint.object.Filter;
      import sailpoint.object.Identity;
      import sailpoint.object.ProvisioningPlan;
      import sailpoint.object.ProvisioningPlan.AccountRequest;
      import sailpoint.object.ProvisioningPlan.AttributeRequest;
      import sailpoint.object.ProvisioningProject;
      import sailpoint.object.QueryOptions;
      import sailpoint.object.SignOffHistory;
      import sailpoint.object.Source;
      import sailpoint.object.Workflow;
      import sailpoint.object.Workflow.Approval;
      import sailpoint.object.WorkItem;
      import sailpoint.object.WorkItem.OwnerHistory;
      import sailpoint.server.Auditor;
      import sailpoint.tools.Util;
      import sailpoint.workflow.IdentityLibrary;
      import sailpoint.workflow.WorkflowContext;

      /**
       * Build an event per forward so there is a record 
       * that the owner changed from the original 
       * owner.
       */
      public void auditWorkItemOwnerHistory(WorkItem item) {
          List ownerHistories = item.getOwnerHistory();
          if ( Util.size(ownerHistories) &gt; 0 ) {
              String action = "Forward";
              if ( Auditor.isEnabled(action) ) {
                  for ( OwnerHistory history : ownerHistories ) {
                      AuditEvent event = new AuditEvent();
                      event.setTrackingId(wfcontext.getWorkflow().getProcessLogId());
                      event.setAction(action);
                      event.setTarget(item.getTargetName());
                      event.setAttribute("workitem", item.getName());
                      String oldOwner = history.getOldOwner();
                      if ( oldOwner != null ) 
                          event.setAttribute("oldOwner", oldOwner);
                      String source = history.getEffectiveSource();
                      event.setSource(source);
                      String comment = history.getComment();
                      if ( comment != null ) 
                          event.setAttribute("comment", comment);
                      String newOwner = history.getNewOwner();
                      if ( newOwner != null ) 
                          event.setAttribute("newOwner", newOwner);

                      // djs: for now set this in both places to avoid needing
                      // to upgrade.  Once we have ui support for "interface"
                      // we can remove the map version
                      event.setAttribute("interface", Source.LCM.toString());
                      event.setInterface(Source.LCM.toString());

                      Auditor.log(event);
                  }
              }
          }
      }

      /**
       * Build a single "comment" event for all of the comments
       * that were entered during a workitems lifecycle.
       */
      public void auditWorkItemComments(WorkItem item) {
          List comments = item.getComments();
          if ( Util.size(comments) &gt; 0 ) {
              String action = "Comment";
              if ( Auditor.isEnabled(action) ) {
                  AuditEvent event = new AuditEvent();
                  event.setTrackingId(wfcontext.getWorkflow().getProcessLogId());
                  event.setAction(action);
                  event.setTarget(item.getTargetName());
                  event.setAttribute("workitem", item.getName());

                  List commentStrings = new ArrayList();
                  for ( Comment comment : comments ) {
                      commentStrings.add(comment.toString());
                  }
                  event.setAttribute("comments", commentStrings);
                  // djs: for now set this in both places to avoid needing
                  // to upgrade.  Once we have ui support for "interface"
                  // we can remove the map version
                  event.setAttribute("interface", Source.LCM.toString());
                  event.setInterface(Source.LCM.toString());
                  Auditor.log(event);
              }
          }
      }

      /**
       * Determine the name to use as the "source" of an LCM work item
       * completion audit.  This should be the name of the identity that
       * closed the item.  This will be different than the item owner if the
       * owner is a work group.
       */
     public String getAuditSource(WorkItem item) {

         String actor = context.getUserName();
         Identity ident = context.getObjectByName(Identity.class, actor);
         if (ident != null)
             actor = ident.getDisplayName();
         else {
             // must be in the background with a pseudo system name
             // fall back to item owner
             ident = item.getOwner();
             if (ident != null)
                 actor = ident.getDisplayName();
             else 
                 actor = launcher;
         }

         return actor;
     }

      public void auditDecisions(WorkItem item) {
          if ( item == null )  return; 

          // there is only one Signoff, duplicated for each approval item
          SignOffHistory signoff = null;
          List signoffs = item.getSignOffs();
          if (signoffs != null &amp;&amp; signoffs.size() &gt; 0)
              signoff = (SignOffHistory)signoffs.get(0);

          ApprovalSet approvalSet = (ApprovalSet)item.get("approvalSet");
          if ( ( approvalSet != null ) &amp;&amp; ( !approvalSet.isEmpty() ) ) {
              for ( ApprovalItem it : approvalSet.getItems() ) {

                  /** Assimilate the form field changes back into the attribute requests before
                  * creating the audit event so that the correct data is stored in the audit event. **/
                  List attrs = it.getIIQAttributes();
                  Form form = (Form)item.get("workItemForm");
                  if(attrs!=null &amp;&amp; form!=null) {
                    for(AttributeRequest attr : attrs) {
                      
                      Field field = form.getField(it.getApplication()+":"+attr.getName());
                      if(field!=null) {
                        attr.setValue(field.getValue());
                      }
                    }
                    it.setValue(flattenAttributeRequests(attrs));                 
                  }
                                    
                  AuditEvent event = new AuditEvent();
                  event.setAction(AuditEvent.ActionApproveLineItem);
                  event.setSource(getAuditSource(item));
                  event.setTarget(identityName);

                  event.setApplication(it.getApplication());
                  event.setAccountName(it.getNativeIdentity());
                  event.setInstance(it.getInstance());
                  event.setAttributeName(it.getName());
                  event.setAttributeValue(it.getCsv());                  
                  
                  // electronic signature
                  if (signoff != null) {
                     String meaning = signoff.getText();
                     if (meaning != null) {
                         event.setAttribute("esignatureSigner", 
                                            signoff.getSignerDisplayableName());
                         event.setAttribute("esignatureText", meaning);
                         // what else, date?
                     }
                 }

                  Date start = it.getStartDate();
                  if ( start != null ) 
                      event.setAttribute("startDate", start);
                  Date end = it.getEndDate();
                  if ( end != null ) 
                      event.setAttribute("endDate", end);

                  event.setAttribute("currentStep", wfcontext.getStep().getName());

                  // group them by a generatedId
                  event.setTrackingId(wfcontext.getWorkflow().getProcessLogId());
                  String interfaceName = wfcontext.getString("interface");
                  if ( interfaceName == null)
                      interfaceName = Source.LCM.toString();

                  // djs: for now set this in both places to avoid needing
                  // to upgrade.  Once we have ui support for "interface"
                  // we can remove the map version
                  event.setAttribute("interface", interfaceName);
                  event.setInterface(interfaceName);

                  event.setAttribute("operation", it.getOperation());
                  event.setAttribute("requester", launcher);

                  List comments = it.getComments();
                  if ( Util.size(comments) &gt; 0 ) {
                      event.setAttribute("completionComments", comments);
                  }

                  String requesterComments = it.getRequesterComments();
                  if ( Util.getString(requesterComments) != null )
                      event.setAttribute("requesterComments", requesterComments);

                  String taskResultId = wfcontext.getString(Workflow.VAR_TASK_RESULT);
                  if ( taskResultId != null ) {
                      event.setAttribute(Workflow.VAR_TASK_RESULT, taskResultId);
                  }

                  if ( !it.isApproved() ) {
                      event.setAction(AuditEvent.ActionRejectLineItem);
                  }

                  if ( Auditor.isEnabled(event.getAction()) ) {
                      Auditor.log(event);
                      wfcontext.getSailPointContext().commitTransaction();
                  }
              }
          }
      }

      public void auditManualAction(WorkItem item) {
          if ( Auditor.isEnabled(AuditEvent.ManualChange) ) {
              ApprovalSet set = (ApprovalSet)item.get("approvalSet");
              if ( set != null ) {
                  List items = set.getItems();
                  if ( Util.size(items) &gt; 0 ) {
                      int num = 0 ;
                      for ( ApprovalItem it : items  ) { 
                          num++;
                          AuditEvent event = IdentityLibrary.buildBaseEvent(wfcontext, it);
                          event.setSource(getAuditSource(item));
                          event.setAction(AuditEvent.ManualChange);
                          event.setAttribute("requester", wfcontext.getString("launcher"));
                          event.setAttribute("op", it.getOperation());
                          List comments = it.getComments();
                          if ( Util.size(comments) &gt; 0 ) {
                              event.setAttribute("completionComments", comments);
                          }
                          Auditor.log(event);
                      }
                      if ( num &gt; 0 ) 
                          wfcontext.getSailPointContext().commitTransaction();
                  }
              } else {
                  throw new GeneralException("ApprovalSet not found in the afterscript.");
              }
          } 
      }

      /**
       * After an approval has been made apply the changes from the workitem back into the
       * cart. (approvalSet)
       */
      public void assimilateWorkItemApprovalSet(WorkflowContext wfcontext, WorkItem item, ApprovalSet approvalSet) {
         if (item == null) {
              // must not be a leaf approval...
              return;
          }
          // Assimilate all of the approvalItem changes into our gloval
          // approval set
          // 
          // Also audit the comments and forwarding thats happend
          ApprovalSet set = (ApprovalSet)item.get("approvalSet");
          if ( set != null ) {
              // Global completion comments will apply to each of the items
              // If there are completion comments append them
              // to any other completion comments, but typically its 
              // one or the other
              String completionComments = item.getCompletionComments();
              String ownerName = null;
              Identity id = item.getOwner();
              if ( id != null ) {
                  ownerName = id.getName();
              }
              approvalSet.assimilate(set, ownerName, completionComments, true);
          } else {
              throw new GeneralException("ApprovalSet not found in the afterscript.");
          }
          auditWorkItemOwnerHistory(item);
          auditWorkItemComments(item);
          wfcontext.getSailPointContext().commitTransaction();
      }

      /**
       * Convert the approvalScheme to csv and check for the approvalType.
       */
      public boolean isApprovalEnabled(String approvalScheme, String approvalType) {
          if ( approvalScheme != null )  {
              List schemes = Util.csvToList(approvalScheme);
              if ( Util.size(schemes) &gt; 0 ) {
                  if ( schemes.contains(approvalType) ) {
                      return true;
                  }
              }
          }
          return false;
      }

      public String getManagerName(String identityName, String launcher, String fallbackApprover) {
          String managerName = getIdentityProperty(identityName, "manager.name");
          if ( managerName != null ) {
              if ( managerName.compareTo(launcher) == 0 ) {
                  managerName = null;
              } 
          } else {
             managerName = fallbackApprover;
          }
          return managerName;
      }

      /**
       * Take an ApprovalSet and allow filtering of rejected items and 
       * allow clearing decisions. If includeRejected is false, only non rejected 
       * items will be copied into the new approvalSet.   If forceDecision is
       * true all of the previous decisions will be cleared forcing the new
       * approver to make a decision on all items.
       */
      public ApprovalSet filterApprovalSet(ApprovalSet masterSet, String includeRejected, 
                                           boolean forceDecision) {
          ApprovalSet filtered = new ApprovalSet();
          if ( masterSet != null ) {
              List items = masterSet.getItems();
              if ( !Util.otob(includeRejected) ) {
                  items = new ArrayList();
                  for ( ApprovalItem item : masterSet.getItems() ) {
                      if ( !item.isRejected() ) {
                          items.add(item);
                      }
                  }
              }
 
              if ( Util.size(items) &gt; 0 )  {
                  for ( ApprovalItem item : items ) {
                      if ( forceDecision ) { 
                          item.setState(null);
                      }
                      filtered.add(item); 
                  } 
              } 
          }
          return filtered;
      }

      //Filter items from the currentSet that are rejected in the masterSet
      public void filterRejectsFromApprovalSet(ApprovalSet masterSet, ApprovalSet currentSet) {
        if (currentSet != null &amp;&amp; !Util.isEmpty(currentSet.getItems())) {
            Iterator it = currentSet.getItems().iterator();
            while(it.hasNext()) {
                ApprovalItem currentItem = (ApprovalItem)it.next();
                //Find the item in the global ApprovalSet
                ApprovalItem globalItem = masterSet.find(currentItem);
                if (globalItem != null &amp;&amp; globalItem.isRejected()) {
                    //remove from the current approval
                    it.remove();
                }
            }
        }

      }

      //Set decisions on the currentSet to those in the masterSet
      public void setPreviousDecisionsOnApprovalSet(ApprovalSet masterSet, ApprovalSet currentSet) {
        if (currentSet != null &amp;&amp; !Util.isEmpty(currentSet.getItems())) {
            Iterator it = currentSet.getItems().iterator();
            while(it.hasNext()) {
                ApprovalItem currentItem = (ApprovalItem)it.next();
                //Find the item in the global ApprovalSet
                ApprovalItem globalItem = masterSet.find(currentItem);
                if (globalItem != null) {
                    currentItem.setState(globalItem.getState());
                }
            }
        }
      }

    
  </Source>
</Rule>
<Rule language="beanshell" name="Check Password Policy" type="FieldValue">
  <Source>
    
       import sailpoint.api.PasswordPolice;
       import sailpoint.object.Application;
       import sailpoint.object.Identity;
       import java.util.List;
       import java.util.ArrayList;
       import sailpoint.api.PasswordPolicyException;
       import sailpoint.tools.Util;
       import sailpoint.tools.Message;
       import sailpoint.tools.GeneralException;

       List msgs = new ArrayList();

       String passVal = (String)value;

       try {
           String appname = field.getApplication();
           if (appname == null) {
              // temporary support old WorkItems
              String fname = field.getName();
              int colon = fname.indexOf(":");
              if (colon &gt; 0)
                 appname = fname.substring(0, colon);
              else
                 log.error("Unable to determine application name from field");
           }
           Application app = context.getObjectByName(Application.class, appname);
          
           PasswordPolice police = new PasswordPolice(context);
           police.checkPassword(app, identity, passVal);
       }
       catch (PasswordPolicyException pe) {
           List messages = pe.getAllMessages();
           for (Message msg : messages) {
               msgs.add(msg.getMessage());
           }
       }
       catch (GeneralException ge) {
           msgs.add(ge.getMessage());
       }

       return ( Util.size(msgs) &gt; 0 ) ? msgs: null;
    
  </Source>
</Rule>
<Rule language="beanshell" name="LCM Build Owner Approvals">
  <ReferencedRules>
    <Reference class="sailpoint.object.Rule" name="Approval Library"/>
  </ReferencedRules>
  <Source>
    
       import sailpoint.object.ApprovalSet;
       import sailpoint.object.ProvisioningPlan;
       import sailpoint.workflow.IdentityLibrary;

       //
       // Attributes needed in the rule context: 
       //
       // plan - ProvisioningPlan object 
       //
       // approvalSet - An ApprovalSet representing the "cart"
       // 
       // fallbackApprover - String representing who gets the approval
       //                    if we can't resolve one.  
       //
       // identityName - name of the identity being operated on
       //
       //
       List approvals = new ArrayList();
       if ( approvalSet != null ) {
           // 
           // Build a map of owner to ApprovalSet from each of the things in the plan 
           // 
           Map ownerMap = buildOwnerMap("owner", approvalSet, plan, fallbackApprover, identityName, !IdentityLibrary.isElectronicSignatureEnabled(wfcontext));
           if ( ownerMap != null) {
               approvals = buildApprovalsFromMap(ownerMap, identityName, launcher);
           } 
       }
       return ( Util.size(approvals) &gt; 0 ) ? approvals : null;
    
  </Source>
</Rule>
<Rule language="beanshell" name="LCM Build Identity Approvers">
  <ReferencedRules>
    <Reference class="sailpoint.object.Rule" name="Approval Library"/>
  </ReferencedRules>
  <Source>
    
       import sailpoint.object.ApprovalSet;
       import sailpoint.object.ProvisioningPlan;
       import sailpoint.object.WorkItem.State;
       import sailpoint.workflow.IdentityLibrary;
       import sailpoint.tools.Util;

       //
       // Attributes needed in the rule context: 
       //
       // plan - ProvisioningPlan object 
       //
       // approvalScheme - String indicating how approvals should be generated
       //   none - disabled
       //   manager - the current manager gets the approval
       //   newManager - the current manager if the manager changd
       //   securityOfficer - the configured security officer
       // 
       // approvalSet - An ApprovalSet representing the "cart"
       //
       // fallbackApprover - String representing who gets the approval
       //                    if we can't resolve one.  
       //
       // identityName - name of the identity being operated on
       //
       // launcher - name of the identity that launched the request
       //
       // securityOfficerName - The name of the securityOfficer to be used
       //                       for approvals.
       //

       // Not all callers pass in securityOfficerName.  If not defined, just set
       // it to null so we don't run into an error when we try to reference it.
       if (void == securityOfficerName) {
           securityOfficerName = null;
       }

       List approvers = new ArrayList();
       if ( approvalSet != null ) {
           List items = approvalSet.getItems();
           // By default there is one item for all of the edits
           ApprovalItem item = null;
           if ( Util.size(items) &gt; 0 ) 
               item = items.get(0); 

           if ( item != null ) {
               approvers = getApproverNames(approvalScheme, item, plan, identityName, securityOfficerName);
               if ( approvers != null &amp;&amp; approvers.size() == 0 &amp;&amp; fallbackApprover != null ) {
                   if ( log.isDebugEnabled() ) { 
                       log.debug("Approver could not be resolved using fallbackApprover '"+fallbackApprover+"'.");
                   }
                   approvers.add(fallbackApprover);
               } 
               // If the launcher is an approver remove them from the list
               if ( approvers != null &amp;&amp; approvers.contains(launcher) ) {
                   Map args = wfcontext.getArguments();
                   String esig = null;
                   if ( args != null ) 
                       esig = (String)args.get("approverElectronicSignature");
 
                   if ( !IdentityLibrary.isElectronicSignatureEnabled(wfcontext) &amp;&amp; Util.isNullOrEmpty(esig) ) {
                       approvers.remove(launcher);
                       // If this is the only approver automaticaly
                       // mark the item approved.
                       if ( Util.size(approvers) == 0 ) {
                           item.setState(WorkItem.State.Finished);
                           item.setOwner(launcher);
                       }
                   }
               }
           }
       }
       return approvers;
    
  </Source>
</Rule>
<Rule language="beanshell" name="LCM Validate Identity Name" type="Validation">
  <Source>
    
      import sailpoint.api.*;
      import sailpoint.object.*;
      import sailpoint.tools.*;
      import sailpoint.api.*;
      import sailpoint.web.messages.MessageKeys;

      QueryOptions qo = new QueryOptions();
      Filter filter  = Filter.ignoreCase(Filter.eq("name", value));
      qo.add(new Filter[]{filter});
      qo.addFilter(ObjectUtil.buildWorkgroupInclusiveIdentityFilter());
      int count = SailPointFactory.getCurrentContext().countObjects(Identity.class,qo);
      List messages = new ArrayList();
      if (count&gt;0) {
          Message msg = new Message();
          msg.setKey(MessageKeys.LCM_CREATE_IDENTITY_NAME_ERROR);
          messages.add(msg);
      }
      return messages;
    
  </Source>
</Rule>
<Rule language="beanshell" name="LCM Validate Password" type="Validation">
  <Source>
    
      import java.util.*;
      import sailpoint.api.PasswordPolice;
      import sailpoint.api.PasswordPolicyException; 
      
      List errors = null;
      
      try {
          PasswordPolice pp = new PasswordPolice(context);
          pp.checkPassword(null, value, false);
      }
      catch (PasswordPolicyException ppe) {
          errors = new ArrayList();
          errors.addAll(ppe.getAllMessages());
      }
      
      return errors;
    
  </Source>
</Rule>
<Rule language="beanshell" name="LCM Build Identity ApprovalSet">
  <ReferencedRules>
    <Reference class="sailpoint.object.Rule" name="Approval Library"/>
  </ReferencedRules>
  <Source>
    
      import sailpoint.object.ProvisioningPlan;
      import sailpoint.object.ProvisioningPlan.AttributeRequest;
      import sailpoint.object.ProvisioningPlan.AccountRequest;
      import sailpoint.object.ApprovalSet;
      import sailpoint.object.ApprovalItem;
      import sailpoint.object.Attributes;
      import sailpoint.tools.Util;

      ApprovalSet set = new ApprovalSet();
      if ( plan != null ) {
          List accountRequests = plan.getAccountRequests();
          for ( AccountRequest request : accountRequests ) {
              ApprovalItem item = new ApprovalItem();
              item.setApplication(request.getApplication());
              item.setInstance(request.getInstance());
              item.setNativeIdentity(request.getNativeIdentity());
              item.setOperation(request.getOperation().toString());
              List attrRequestFlat = flattenAttributeRequests(request.getAttributeRequests());
              if ( attrRequestFlat != null ) {
                  item.setValue(attrRequestFlat);
              } 
              Attributes attributes = getAttributeRequestArguments(request.getAttributeRequests());
              item.setAttributes(attributes);
              
              // for these requests comments come in on the plan
              String comments = plan.getComments();
              if ( Util.getString(comments) != null ) {
                  item.setRequesterComments(comments);
              }
              set.add(item);
          }

          // while we are here lets annotate the plan with previousValues
          if ( flow.equals("IdentityEditRequest") ) {
              AccountRequest iiqRequest = plan.getAccountRequest("IIQ");    
              if ( iiqRequest != null ) {
                  List attributeRequests = iiqRequest.getAttributeRequests();
                  if ( Util.size(attributeRequests) &gt; 0 ) {
                      Identity id = context.getObject(Identity.class, identityName);
                      if ( id != null )  {
                          for ( AttributeRequest req : attributeRequests ) {
                              String name = req.getName();
                              if ( name != null ) {
                                  // We have to be carefull here, if we see manager display
                                  // the displayName
                                  Object prevValue = id.getAttribute(name);
                                  if ( prevValue != null ) {
                                      if (name.equals("manager") ) {
                                          String displayName = getIdentityProperty((String)prevValue, "displayName");
                                          if ( displayName != null ) {
                                              prevValue = displayName;
                                          }
                                      }
                                      else if (prevValue instanceof Identity) {
                                          prevValue = (String)prevValue.getDisplayableName();
                                      }
                                      else  if(prevValue instanceof List) {
                                          /* Thanks to type erasure there is no way for us to write something like
                                           * prevValue instanceof List&lt;Identity&gt; so break it into steps.  Check if
                                           * prevValue is a List.  If it has any elements get the first one. If that
                                           * is an instance of Identity then assume the rest of the elements are too
                                           * and then build a List of displayable names, because that is what we do
                                           * with Identitys. */
                                          List prevValueList = (List) prevValue;
                                          if(prevValueList.size() &gt; 0) {
                                              if(prevValueList.get(0) instanceof Identity) {
                                                  List identityIds = new ArrayList(prevValueList.size());
                                                  for (Object value : prevValueList) {
                                                      Identity identity = (Identity) value;
                                                      identityIds.add(identity.getDisplayableName());
                                                  }
                                                  prevValue = identityIds;
                                              }
                                          }
                                      }
                                      req.put(ProvisioningPlan.ARG_PREVIOUS_VALUE, prevValue);
                                  }
                              }
                          }
                      }
                  }
              }
          }
      }
      return set;
    
  </Source>
</Rule>
<Rule language="beanshell" name="Objects in Requestor's Authorized Scopes" type="RequestObjectSelector">
  <Description>
    This rule returns either a Filter object that will be used to search for objects in the requestor's authorized scopes,
    the boolean value 'true' to indicate that everything should be returned (i.e. no restrictions) 
    or the boolean value 'false' to indicate that no objects are available for this user
  </Description>
  <Signature returnType="sailpoint.object.QueryInfo">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="requestor" type="sailpoint.object.Identity">
        <Description>
          Identity that is making the Life Cycle Manager request.
        </Description>
      </Argument>
      <Argument name="requestee" type="sailpoint.object.Identity">
        <Description>
          Identity on whose behalf the Life Cycle Manager request is being made.  In the case of bulk requests,
          this argument will be set to null when determining the roles that are visible to the requestor.
          It will be provided once a selection has been made in order to determine whether or not the given requestee
          should have access to the selected role.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="filter">
        <Description>
          Either a Filter object that will be used to search for accessible Objects, the boolean value 'true' to indicate that everything should be
          returned (i.e. no restrictions) or the boolean value 'false' to indicate that no objects are available for this population 
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    
      import sailpoint.api.ScopeService;
      
      ScopeService scopeService = new ScopeService(context);
      return scopeService.getControlledScopesQueryInfo(requestor);
    
  </Source>
</Rule>
<Rule language="beanshell" name="Objects in Requestee's Assigned Scope" type="RequestObjectSelector">
  <Description>This rule returns a Filter that restricts objects to those in the requestee's assigned scope</Description>
  <Signature returnType="sailpoint.object.QueryInfo">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="requestor" type="sailpoint.object.Identity">
        <Description>
          Identity that is making the Life Cycle Manager request.
        </Description>
      </Argument>
      <Argument name="requestee" type="sailpoint.object.Identity">
        <Description>
          Identity on whose behalf the Life Cycle Manager request is being made.  In the case of bulk requests,
          this argument will be set to null when determining the objects that are visible to the requestor.
          It will be provided once a selection has been made in order to determine whether or not the given requestee
          should have access to the selected role.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="filter">
        <Description>
          Either a Filter object that will be used to search for accessible Objects, the boolean value 'true' to indicate that everything should be
          returned (i.e. no restrictions) or the boolean value 'false' to indicate that no objects are available for this population 
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    
      import sailpoint.api.ScopeService;
      import sailpoint.object.Identity;
      import sailpoint.object.Scope;
      import sailpoint.object.QueryOptions;
      import sailpoint.object.QueryInfo;

      ScopeService scopeService = new ScopeService(context);
      QueryInfo scopeQueryInfo;
      if (requestee == null) {
          scopeQueryInfo = new QueryInfo(new QueryOptions());
      } else {
          scopeQueryInfo = scopeService.getAssignedScopeQueryInfo(requestee);
      }
      
      return scopeQueryInfo;
    
  </Source>
</Rule>
<Rule language="beanshell" name="Objects in Requestor's Authorized Scopes or Requestee's Assigned Scope" type="RequestObjectSelector">
  <Description>This rule returns a Filter that restricts roles to those in the requestor's authorized scopes or the requestee's assigned scope</Description>
  <Signature returnType="sailpoint.object.QueryInfo">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="requestor" type="sailpoint.object.Identity">
        <Description>
          Identity that is making the Life Cycle Manager request.
        </Description>
      </Argument>
      <Argument name="requestee" type="sailpoint.object.Identity">
        <Description>
          Identity on whose behalf the Life Cycle Manager request is being made.  In the case of bulk requests,
          this argument will be set to null when determining the roles that are visible to the requestor.
          It will be provided once a selection has been made in order to determine whether or not the given requestee
          should have access to the selected role.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="filter">
        <Description>
          A Filter object that will be used to search for accessible objects.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    
        import sailpoint.api.ScopeService;
        import sailpoint.object.Filter;
        import sailpoint.object.Identity;
        import sailpoint.object.QueryInfo;
        import sailpoint.object.QueryOptions;        

        ScopeService scopeService = new ScopeService(context);
        QueryInfo requestorQueryInfo =  scopeService.getControlledScopesQueryInfo(requestor);
        QueryInfo requesteeQueryInfo;
        if (requestee == null) {
            requesteeQueryInfo = null;
        } else {
            requesteeQueryInfo =  scopeService.getAssignedScopeQueryInfo(requestee);
        }

        QueryInfo scopeQueryInfo;
        if (requesteeQueryInfo == null || requesteeQueryInfo.isReturnNone()) {
            // Either no requestee was available or the requestee doesn't have anything in scope.  
            // Only apply the requestor QueryInfo in either case.
            scopeQueryInfo = requestorQueryInfo;
        } else if (requestorQueryInfo != null &amp;&amp; !requestorQueryInfo.isReturnNone()) {
            if (requestorQueryInfo.isReturnAll() || requesteeQueryInfo.isReturnAll()) {
                // If either the requestor or requestee has access to everything create a QueryInfo that grants
                // access to everything
                scopeQueryInfo = new QueryInfo(new QueryOptions());
            } else {
                // Both requestee and requestor filters exist so 'or' them
                scopeQueryInfo = new QueryInfo(Filter.or(requestorQueryInfo.getFilter(), requesteeQueryInfo.getFilter()), false);
            }
        } else {
            // The requestor doesn't have access to anything so only return whatever the requestee has access to
            scopeQueryInfo = requesteeQueryInfo;
        }

        return scopeQueryInfo;
    
  </Source>
</Rule>
<Rule language="beanshell" name="Objects Owned by the Requestor" type="RequestObjectSelector">
  <Description>This rule returns a Filter that restricts objects to those that the requestor or one of their workgroups owns</Description>
  <Signature returnType="sailpoint.object.QueryInfo">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="requestor" type="sailpoint.object.Identity">
        <Description>
          Identity that is making the Life Cycle Manager request.
        </Description>
      </Argument>
      <Argument name="requestee" type="sailpoint.object.Identity">
        <Description>
          Identity on whose behalf the Life Cycle Manager request is being made.  In the case of bulk requests,
          this argument will be set to null when determining the objects that are visible to the requestor.
          It will be provided once a selection has been made in order to determine whether or not the given requestee
          should have access to the selected object.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="filter">
        <Description>
          A Filter object that will be used to search for accessible Objects.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    
      import sailpoint.object.Filter;
      import sailpoint.object.Identity;
      import sailpoint.object.QueryOptions;
      import sailpoint.object.QueryInfo; 
      return new QueryInfo(QueryOptions.getOwnerScopeFilter(requestor, "owner"), false);
    
  </Source>
</Rule>
<Rule language="beanshell" name="All Objects" type="RequestObjectSelector">
  <Description>Allows all objects to be selected (no filtering)</Description>
  <Signature returnType="sailpoint.object.Filter">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="requestor" type="sailpoint.object.Identity">
        <Description>
          Identity that is making the Life Cycle Manager request.
        </Description>
      </Argument>
      <Argument name="requestee" type="sailpoint.object.Identity">
        <Description>
          Identity on whose behalf the Life Cycle Manager request is being made.  In the case of bulk requests,
          this argument will be set to null when determining the roles that are visible to the requestor.
          It will be provided once a selection has been made in order to determine whether or not the given requestee
          should have access to the selected role.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="filter">
        <Description>
          A Filter object that will be used to search for accessible request objects.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import sailpoint.object.QueryInfo;

return new QueryInfo(null, false);</Source>
</Rule>
<Rule language="beanshell" name="Identity Report Form Customizer" type="ReportCustomizer">
  <Description>
    This rule populates a form with fields for the standard and extended identity attributes.
  </Description>
  <Signature returnType="Map">
    <Inputs>
      <Argument name="locale">
        <Description>
          The current user's locale
        </Description>
      </Argument>
      <Argument name="report">
        <Description>
          The base report
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
       
        import sailpoint.object.*;
        import sailpoint.reporting.ReportingLibrary;

        ObjectConfig identityConfig = ObjectConfig.getObjectConfig(Identity.class);
        List standardAttributes = new ArrayList();
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("firstname"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("lastname"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("displayName"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("email"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("manager"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("inactive"));

        ReportingLibrary.addAttributes(context, report, Identity.class, standardAttributes, null,
          "Identity Attributes", locale, "id");

        List extendedAttrs = new ArrayList();
        for(ObjectAttribute att : identityConfig.getSearchableAttributes()){
          if (!att.isStandard())
            extendedAttrs.add(att);
        }

        for(ObjectAttribute att : identityConfig.getMultiAttributeList()){
            extendedAttrs.add(att);
        }

        ReportingLibrary.addAttributes(context, report, Identity.class, extendedAttrs, null,
          "Identity Extended Attributes", locale, "id");


       
</Source>
</Rule>
<Rule language="beanshell" name="Identity Entitlement Identity Report Form Customizer" type="ReportCustomizer">
  <Description>
    This rule populates a form with fields for the standard and extended identity attributes accessed through an identity entitlement.
  </Description>
  <Signature returnType="Map">
    <Inputs>
      <Argument name="locale">
        <Description>
          The current user's locale
        </Description>
      </Argument>
      <Argument name="report">
        <Description>
          The base report
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
       
        import sailpoint.object.*;
        import sailpoint.reporting.ReportingLibrary;

        ObjectConfig identityConfig = ObjectConfig.getObjectConfig(Identity.class);
        List standardAttributes = new ArrayList();
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("firstname"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("lastname"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("displayName"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("email"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("manager"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("inactive"));

        ReportingLibrary.addAttributes(context, report, IdentityEntitlement.class, standardAttributes, "identity",
          "Identity Attributes", locale, "id");


        List extendedAttrs = new ArrayList();
        for(ObjectAttribute att : identityConfig.getSearchableAttributes()){
          if (!att.isStandard())
            extendedAttrs.add(att);
        }

        for(ObjectAttribute att : identityConfig.getMultiAttributeList()){
            extendedAttrs.add(att);
        }

        ReportingLibrary.addAttributes(context, report, IdentityEntitlement.class, extendedAttrs, "identity",
          "Identity Extended Attributes", locale, "id");


       
</Source>
</Rule>
<Rule language="beanshell" name="Account Report Form Customizer" type="ReportCustomizer">
  <Description>
    This rule populates a form with fields for all searchable account fields.
  </Description>
  <Signature returnType="Map">
    <Inputs>
      <Argument name="locale">
        <Description>
          The current user's locale
        </Description>
      </Argument>
      <Argument name="report">
        <Description>
          The base report
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
       
        import sailpoint.object.*;
        import sailpoint.reporting.ReportingLibrary;

        ObjectConfig linkConfig = ObjectConfig.getObjectConfig(Link.class);
        ReportingLibrary.addAttributes(context, report, Link.class, linkConfig.getSearchableAttributes(), null,
          "Account Properties", locale);
       
</Source>
</Rule>
<Rule language="beanshell" name="Certification Report Customizer" type="ReportCustomizer">
  <Source>
       
        import sailpoint.object.*;
        import sailpoint.tools.Util;
        import sailpoint.web.messages.MessageKeys;
        if (Util.otob(taskDefinition.getArgument("exclusions"))){
          report.setDisablePreview(true);
          report.setDisablePreviewMessage(MessageKeys.REPT_CERT_PREVIEW_DISABLED_EXCLUSIONS);
        } else {
          report.setDisablePreview(false);
          report.setDisablePreviewMessage(null);
        }

       
</Source>
</Rule>
<Rule language="beanshell" name="Privileged Access Report Customizer" type="ReportCustomizer">
  <Description>
    This rule populates a form with fields for the standard and extended identity attributes as well as
    a form for defining the 'privileged' identity attribute.
  </Description>
  <Signature returnType="Map">
    <Inputs>
      <Argument name="locale">
        <Description>
          The current user's locale
        </Description>
      </Argument>
      <Argument name="report">
        <Description>
          The base report
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
       
        import sailpoint.object.*;
        import sailpoint.reporting.ReportingLibrary;

        ObjectConfig linkConfig = ObjectConfig.getObjectConfig(Link.class);
        ReportingLibrary.addAttributes(context, report, Link.class, linkConfig.getSearchableAttributes(), null,
          "Privileged Account Attributes", locale, "id");


        ObjectConfig identityConfig = ObjectConfig.getObjectConfig(Identity.class);
        List standardAttributes = new ArrayList();
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("firstname"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("lastname"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("displayName"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("email"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("manager"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("inactive"));

        ReportingLibrary.addAttributes(context, report, Identity.class, standardAttributes, "identity",
          "Identity Properties", locale, "id");

        List extendedAttrs = new ArrayList();
        for(ObjectAttribute att : identityConfig.getSearchableAttributes()){
          if (!att.isStandard())
            extendedAttrs.add(att);
        }

        for(ObjectAttribute att : identityConfig.getMultiAttributeList()){
            extendedAttrs.add(att);
        }

        ReportingLibrary.addAttributes(context, report, Identity.class, extendedAttrs, "identity",
          "Identity Extended Properties", locale, "id");
       
</Source>
</Rule>
<Rule language="beanshell" name="Privileged Access Report Validation Rule" type="ReportValidator">
  <Description>
      This rule validates the Privileged Access Report Form
    </Description>
  <Signature returnType="java.util.List">
    <Inputs>
      <Argument name="context">
        <Description>
            A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
          </Description>
      </Argument>
      <Argument name="report">
        <Description>
            The report object
          </Description>
      </Argument>
      <Argument name="form">
        <Description>
            The submitted sailpoint Form object.
          </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="messages">
        <Description>
            A list of error messages.
          </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
      
       import java.util.*;
       import sailpoint.object.*;
       import sailpoint.tools.Message;
       List messages = new ArrayList();

       Form.Section section = form.getSection("Privileged Account Attributes");
       if (section != null) {
         boolean found = false;
         for(FormItem item : section.getItems()){
           Field field = (Field)item;
           if(field.getValue() != null &amp;&amp; !field.getValue().equals("") &amp;&amp; !field.getValue().equals("null")) {
             found = true;
           }
         }

         if (!found) {
           messages.add(Message.localize("rept_priv_access_err_no_attr"));
         }
       } else {
         messages.add(Message.localize("rept_priv_attr_setup_needed"));
       }

       return messages;
      
  </Source>
</Rule>
<Rule language="beanshell" name="WindowsActivityRuleLibrary">
  <Source>
    
      import java.util.HashMap;
      import java.util.ArrayList;
      import java.util.List;
      import sailpoint.object.ApplicationActivity;
      import sailpoint.object.ApplicationActivity.Action;
      import sailpoint.tools.xml.*;

      public static String ACCESSES = "Accesses";
      public static String PRIVS = "Privileges";

      /**
       * Build a name,value Map pairing of the data found
       * in the Message field of the windows event.
       * Most of the low-level data is usually stored 
       * there using a "name : value \n" format, so parse
       * out those values so we can use them when 
       * building our activity.
       */
      public HashMap buildMapFromMessage(String message) {
  
          HashMap attributeMap = new HashMap();
          if ( message == null ) return attributeMap;

          StringTokenizer st = new StringTokenizer(message, "\n");
          int tokenNum = 0;
          while ( st.hasMoreTokens() ) {
              tokenNum++;
              String token = st.nextToken();
//System.out.println("token :" + token);
              String[] values = token.split(":");
              if ( values == null ) continue;
              if ( values.length == 2 ) {
                  String name = values[0];
                  String value = values[1];
                  if ( ( name != null ) &amp;&amp; ( value != null ) ) {
//System.out.println("name: " + name.trim() + " value: " + value.trim());
                      attributeMap.put(name.trim(), value.trim());
                  }
              } else 
              if ( (values.length == 1) &amp;&amp; (tokenNum == 1) ) {
                  String name = values[0];
                  attributeMap.put("action", name.trim());
              }
          }
          // Parse out privs 
          addPrivileges(attributeMap, message); 

          return attributeMap;
      }

      /** 
       * Some events, mostly Object Access events contain
       * Accesses, Privleges that need to be parsed further.
       * This is called, when we build a Map if the Message.
       */
      public void addPrivileges(HashMap extraInfo, String message) {

          if ( message== null ) return;
          int i = message.indexOf(ACCESSES);
          if ( i == -1 ) {
//System.out.println(ACCESSES + " not found");
              return;
          }
          int j = message.indexOf(PRIVS);
          if ( j == -1 ) {
//System.out.println(PRIVS + " not found");
              return;
          }

          List accesses = new ArrayList();
          String lastBlock = message.substring(i+ACCESSES.length(), j-1);
          if ( lastBlock != null ) {
//System.out.println("***lastBlock: " + lastBlock);
              StringTokenizer st = new StringTokenizer(lastBlock, "\n");
              while ( st.hasMoreTokens() ) {
                  String access = st.nextToken();
                  if ( access != null ) {
                      String trimed = access.trim();
                      if ( trimed.length() &gt; 0 ) {
//System.out.println("access: '" + trimed + "'");
                          accesses.add(trimed);
                      }
                  }
              }
          }

          if ( accesses.size() &gt; 0 ) {
              extraInfo.put(ACCESSES, accesses);
          }
      }

      /**
       * Given the eventCode from the native windows event
       * map it to our Action.
       */
      public Action resolveAction(Integer eventCode, HashMap extraInfo) {
          Action action = null;

          if ( eventCode == null ) {
              return;
          }

          try {
              switch(eventCode) {
                  case 538:
                      // logout
                      action = Action.Logout;
                      break;
                  case 528:
                  case 540:
                      // login
                      action = Action.Login;
                      break;
                  case 564:
                      // object delted
                      action = Action.Delete;
                      break;
                  case 560:
                      // object open
                      // Very generic must dig in an check permissions
                      if (containsAccess("WriteAttributes", extraInfo))
                          action = Action.Update;
                      else
                      if ( containsAccess("DELETE", extraInfo) ) 
                          action = Action.Delete;
                      else 
                          action = Action.Read;
                      break;
                  default: 
                      // not sure we should even have a default case?
                      action = Action.Read;
                      break;
              }
          } catch(Exception e) {
              action = null;
          }
          return action;
      }

      /** 
       * Using the resolved action, use the data in the extraInfo
       * map to come up with a target. ( the thing that was acted upon)
       */
      public String resolveTarget(Action action, HashMap extraInfo) {

          String target = null;    
          if ( ( action == null ) || ( extraInfo == null )  ) {
              return target;
          }

          if ( ( action.equals(Action.Login) ) ||
               ( action.equals(Action.Logout) ) ) {
              target = (String)extraInfo.get("Domain");
          } else {
              target = (String)extraInfo.get("Object Name");
          }

          if ( target == null ) target = "unResolved";
          return target;
      }


      /** 
       * Dig into the extra info and see if the event has referece to 
       * the past in access. 
       */
      private boolean containsAccess(String access, HashMap extraInfo) {

          boolean contains = false;
          if ( extraInfo == null ) return contains;

          ArrayList accesses = (ArrayList)extraInfo.get(ACCESSES); 
          if ( accesses != null ) {
              for ( String access: accesses ) {
                  if ( access != null ) {
                      if ( access.compareTo(access) == 0 ) {
                          return true;
                      }
                  }
              }        
          }
          return contains;
      }
    
  </Source>
</Rule>
<Rule language="beanshell" name="System Configured Locale Rule" type="FieldValue">
  <Description>
    This rule returns the locales configured in the System Configuration.
  </Description>
  <Signature returnType="java.util.List">
    <Inputs>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="locales">
        <Description>
          A list containing the locales found in the System Configuration.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
      import java.util.*;
     Map sysConfig = context.getConfiguration().getAttributes();
     List locales = sysConfig.get("supportedLanguages");
     return locales;
</Source>
</Rule>
<Rule language="beanshell" name="Report Completion Notification" type="TaskEventRule">
  <Description>
    This rule sends a notification email when a report is completed.
  </Description>
  <Signature returnType="Map">
    <Inputs>
      <Argument name="taskResult">
        <Description>
          The TaskResult object
        </Description>
      </Argument>
      <Argument name="event">
        <Description>
          The TaskEvent object
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="taskResult">
        <Description>The resulting task result object, or null if no update is required.</Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
      
        import sailpoint.object.*;
        import java.util.*;

        String identity = (String)event.getAttribute(TaskEvent.ATTR_EMAIL_RECIP);

        if (identity != null){

          Identity identity = context.getObjectByName(Identity.class, identity);
          if (identity == null)
            return result;

          List emailAddresses = new ArrayList();
          emailAddresses.add(identity.getEmail());
          EmailOptions options = new EmailOptions(emailAddresses, null);
          options.setSendImmediate(true);

          Map emailVars = new HashMap();
          emailVars.put("reportName", taskResult.getName());
          options.setVariables(emailVars);

          String templateName = (String)context.getConfiguration().get(Configuration.REPORT_COMPLETION_EMAIL_TEMPLATE);
          EmailTemplate et = context.getObjectByName(EmailTemplate.class, templateName);

          context.sendEmailNotification(et, options);
        }

        return null;
      
</Source>
</Rule>
<Rule language="beanshell" name="Report Scorecard Value Renderer">
  <Description>
      This rule renders report columns which pull values from a Scorecard object.
    </Description>
  <Source>
      
       import java.util.*;
       import sailpoint.object.*;

       Integer score = null;
       if(value!=null) {
					score = value.getScore(column.getField());
			 }

       return score != null ? score.toString() : null;
      
  </Source>
</Rule>
<Rule language="beanshell" name="Task Completion Email Rule" type="TaskCompletion">
  <Description>
      Example rule to perform Post Action after Task Completion
    </Description>
  <Signature>
    <Inputs>
      <Argument name="context">
        <Description>
            A sailpoint.api.SailPointContext object 
          </Description>
      </Argument>
      <Argument name="log">
        <Description>
            The log object associated with the SailPointContext.
          </Description>
      </Argument>
      <Argument name="result">
        <Description>
            result of task.
          </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
      
          import java.util.*;
          import sailpoint.tools.Util;
          import sailpoint.tools.GeneralException;
          import sailpoint.object.Configuration;
          import sailpoint.object.EmailOptions;
          import sailpoint.object.EmailTemplate;
          import sailpoint.object.TaskResult;
          import sailpoint.object.Identity;
          import sailpoint.object.TaskDefinition;
          import sailpoint.api.MessageRepository;
          import sailpoint.api.Emailer;
          import sailpoint.api.BasicMessageRepository;
          import sailpoint.api.ObjectUtil;
          import sailpoint.api.SailPointContext;

          MessageRepository _errorHandler;

          /**
           * Method to send email
          */
          private void sendEmailOnTaskCompletion(String emailTemplate, ArrayList recipients, TaskResult result, SailPointContext context) {
              String message = "";
              String status = "";
              TaskDefinition def;
              Configuration sysConfig;

              def = result.getDefinition();
              EmailTemplate notifyEmail =  context.getObjectByName(EmailTemplate.class, emailTemplate);
              if (null == notifyEmail) {
                  log.error ("From Task Completion Email Rule: ERROR: could not find email template [ " + emailTemplate + "]");
                  return;
              }
              notifyEmail = (EmailTemplate) notifyEmail.deepCopy(context);
              if (null == notifyEmail) {
                  log.error ("From Task Completion Email Rule: ERROR: failed to deepCopy template [ " + emailTemplate + "]");
                  return;
              }
              // For now, we'll just use a map with a few pre-selected properties.
              Map mArgs = new HashMap();
 
              mArgs.put("taskResult", result);
              mArgs.put("taskName", def.getName());
              mArgs.put("taskDesc", def.getDescription());
              if (result.isError()) {
                  status = "Error";
              }
              else  if (result.isWarning()) {
                  status = "Warning";
              }
              else if (result.isSuccess()) {
                  status = "Success";
              }
 
              mArgs.put("taskStartTime", result.getLaunched() );
              mArgs.put("taskEndTime", result.getCompleted() );
              mArgs.put("status", status);
              if (result.getMessages() != null) {
                  mArgs.put("message", result.getMessages());
              }
              mArgs.put ("resultId", result.getId());

              EmailOptions ops = new EmailOptions(recipients, mArgs);
              new Emailer(context, _errorHandler).sendEmailNotification(notifyEmail , ops);
          }

          private boolean isEmailNotificationEnabled(TaskResult result, Configuration sysConfig) {
              boolean sendEmail = false;
              String notifyStr = null;

              TaskDefinition def = result.getDefinition();
              notifyStr = (String) def.getString(Configuration.TASK_COMPLETION_EMAIL_NOTIFY);
              if (notifyStr == null) {
                  notifyStr = sysConfig.getString(Configuration.TASK_COMPLETION_EMAIL_NOTIFY);
              }

              if (notifyStr != null) {
                  if (notifyStr.equals("Always") ||
                      ((notifyStr.equals("Failure")) &amp;&amp; result.isError()) || 
                      ((notifyStr.equals("Warning")) &amp;&amp;
                       (result.isWarning() || result.isError()))) {
                      sendEmail = true;
                  }
              }
                      
              return sendEmail;
          }

          private Object getIdentityNames(TaskResult result, Configuration sysConfig) {
              
              TaskDefinition def = result.getDefinition();
              Object identityNames = def.getArgument(Configuration.TASK_COMPLETION_RECIPIENTS);
              if (identityNames == null) {
                  identityNames = sysConfig.get(Configuration.TASK_COMPLETION_RECIPIENTS);
              }
              return identityNames;
          }

          private String getEmailTemplate(TaskResult result, Configuration sysConfig) {
              TaskDefinition def = result.getDefinition();
              String emailTemplate = def.getString(Configuration.TASK_COMPLETION_EMAIL_TEMPLATE);
              if (emailTemplate == null) {
                  emailTemplate = sysConfig.getString(Configuration.TASK_COMPLETION_EMAIL_TEMPLATE);
                  if (emailTemplate == null)
                      emailTemplate = Configuration.DEFAULT_TASK_COMPLETION_EMAIL_TEMPLATE;
              }
              return emailTemplate;
          }

          private List getEmailAddress (String identityName, SailPointContext context) {
              Identity identity = context.getObjectByName(Identity.class, identityName);
              if (identity != null) 
              {
                  List addresses = ObjectUtil.getEffectiveEmails(context, identity);
                  if (!Util.isEmpty(addresses)) {
                      return(addresses);
                  }
                  else
                  {
                     if(log.isWarnEnabled()) {
                         log.warn("From Task Completion Email Rule: Missing Email Address for Email Recipient: " + identityName );
                     }
                  }
              }
              return (null);
          }

          private ArrayList getEmailRecipient (Object identityNames, SailPointContext context) {
              List recipients;
              String val = null;
              StringTokenizer st = null;
              if (identityNames != null) {
                  recipients = new ArrayList ();
                  // From Task definition, single identity
                  if (identityNames instanceof String  &amp;&amp; !identityNames.contains(",")) {
                      List addresses = getEmailAddress (identityNames.toString(), context);
                      if (addresses != null) {
                         recipients.addAll (addresses);
                      }
                  }
                  // From Task definition, multiple identities
                  else if (identityNames instanceof String  &amp;&amp; identityNames.contains(",") == true) {
                      List nameList = Util.csvToList(identityNames);
                      for (String identityName : nameList) {
                          List addresses = getEmailAddress (identityName, context);
                          if (addresses != null) {
                              recipients.addAll (addresses);
                          }
                      }  
                  } 
                  // From system configuration single or multiple identities it comes as list
                  else if (identityNames instanceof List) {
                      for (String identityName : identityNames) {
                          List addresses = getEmailAddress (identityName, context);
                          if (addresses != null) {
                              recipients.addAll(getEmailAddress (identityName, context));
                          }
                      }
                  }
              }
              return (recipients);
          }

          // Main
          Configuration sysConfig = context.getConfiguration();
          boolean sendEmailNotify = isEmailNotificationEnabled(result, sysConfig);
    
          if (sendEmailNotify) {
              // jsl - why consturct this here, just make it in
              // sendEmailOnTaskCompletion where it is used?
              // why do this at all since no one consumes it?
              _errorHandler = new BasicMessageRepository();

              Object identityNames = getIdentityNames(result, sysConfig);
              String emailTemplate = getEmailTemplate(result, sysConfig);
              List recipients = getEmailRecipient(identityNames, context);

              if (recipients != null &amp;&amp; !Util.isEmpty(recipients)) {
                    // Send Email
                   sendEmailOnTaskCompletion(emailTemplate, recipients, result, context);
              }
              else {
                  if(log.isWarnEnabled()) {
                      log.warn("From Task Completion Email Rule: Cannot send task completion email Notification. Reason : Missing Email Address for Email Recipients");
                  }
              }
          }
    
    </Source>
</Rule>
<Rule language="beanshell" name="CEFTransformRule" type="ActivityTransformer">
  <Description>ActivityTransformation Rules are used by the LogFileCollector to transform fields parsed from a text file into our ApplicationActivity model.</Description>
  <Signature returnType="String">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="action">
        <Description>
          The field named action, which is the raw parsed.
          action field.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="mappedAction">
        <Description>
          A normalized ApplicationActivity.Action object.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import sailpoint.object.ApplicationActivity.Action;
import sailpoint.object.ApplicationActivity.Result;
import java.text.SimpleDateFormat;
import java.io;
import sailpoint.object.Configuration;
import java.util.List;

activity.setAction(Action.Grant);
activity.setResult(Result.Success);

//Dump out all params from CEF log entry to console
//System.out.println("CEFTransformRule: In rule");        
//System.out.println("CEFTransformRule: Timestamp=" +cef_timestamp);
//System.out.println("CEFTransformRule: Host=" +cef_host);
//System.out.println("CEFTransformRule: CEFVersion=" + cef_cefversion);
//System.out.println("CEFTransformRule: Vendor=" + cef_vendor);
//System.out.println("CEFTransformRule: Product=" + cef_product);
//System.out.println("CEFTransformRule: Version=" + cef_version);
//System.out.println("CEFTransformRule: Signature=" + cef_signature);
//System.out.println("CEFTransformRule: Name=" + cef_name);
//System.out.println("CEFTransformRule: Severity=" + cef_severity);
//System.out.println("CEFTransformRule: Explanation=" + cef_explanation);

//Find the user parameter in CEF Explanation field
//System.out.println("CEFTransformRule: Breaking down the parameter list.....:");

Object o= Configuration.getSystemConfig().getList(Configuration.ATT_CEF_USER_NAME);
List cefUserNames = null;
if (o instanceof List) {
            cefUserNames = (List)o;
}

for (String paramPair: cef_explanation.split("\\s(?=\\S*(?&lt;!\\\\)=)", 0)){
//	System.out.println("CEFTransformRule: Parameter pair found " + paramPair);
    for(String cefUser: cefUserNames){
        String cefUserParam = cefUser.concat("=.*");
        if (paramPair.matches(cefUserParam)) {
            cef_user = paramPair.split("=",2)[1];
//            System.out.println("CEFTransformRule: duser parameter found! " + cef_user);
        }
    }   
}

// Set activity values
activity.setUser(cef_user);
activity.setAction(Action.Login);
activity.setResult(Result.Success);
activity.setInfo("vendor=" + cef_vendor + " host=" + cef_host + " " + cef_explanation + " severity=" + cef_severity + " product=" + cef_product);
activity.setTarget(cef_name);

// Set timestamp from CEF header, but add current year as this is not supplied
SimpleDateFormat f = new SimpleDateFormat("MMM dd hh:mm:ss yyyy");
defaultYear = Calendar.getInstance().get(Calendar.YEAR);
Date date = date = f.parse(cef_timestamp + " " + defaultYear);
activity.setTimeStamp(date);

return activity;</Source>
</Rule>
<Rule language="beanshell" name="CEFActivityCorrelation" type="ActivityCorrelation">
  <Description>Rule to show how an CEF activity might be correlated back to an identity. In most cases, this rule will be providing enought information to the correlator so that it can find the Application link. In some cases, it might also be desireable to return something that points back to an Identity, which is also supported.</Description>
  <Signature returnType="Map">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="application">
        <Description>
          The application where the activity was generated.
          An application may have more then one data source.
        </Description>
      </Argument>
      <Argument name="datasource">
        <Description>
          The data source that returned the activity.
        </Description>
      </Argument>
      <Argument name="activity">
        <Description>
          The activity object that was normalized by
          the data source and that we are trying to
          correlate back to one of our Identities.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="linkIdentity">
        <Description>
          A string that represents the link's identity attribute.
        </Description>
      </Argument>
      <Argument name="linkName">
        <Description>
          A string that represents the link's displayName attribute.
        </Description>
      </Argument>
      <Argument name="linkAttributeName">
        <Description>
          A string that represents the NAME of an attribute that
          can be used to find the Link that maps back to this
          activity.  This attribute must also be supplied
          with the linkAttributeValue variable.
        </Description>
      </Argument>
      <Argument name="linkAttributeValue">
        <Description>
          A string that represents the VALUE of an attribute that
          can be used to find the Link that maps back to this
          activity. This attribute must also be supplied
          with the linkAttributeName variable.
        </Description>
      </Argument>
      <Argument name="identityName">
        <Description>
          The name of an Identity object.
        </Description>
      </Argument>
      <Argument name="identity">
        <Description>
          A fully resolved Identity object in case the rule wants
          to do its own queries to locate the identity.
        </Description>
      </Argument>
      <Argument name="identityAttributeName">
        <Description>
          The name of the extended attribute that can be used
          to locate an existing identity.
        </Description>
      </Argument>
      <Argument name="identityAttributeValue">
        <Description>
          The value of the named extended attribute that can be used
          to locate an existing identity. This attribute is used
          together with the identityAttributeName argument.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import sailpoint.object.ApplicationActivity;
  import sailpoint.object.Configuration;
	
//  System.out.println("CEFActivityCorrelation: In Correlation Rule");

    Map returnMap = new HashMap();
    String user = activity.getUser();
	String cefLinkAttributeName = Configuration.getSystemConfig().getString(Configuration.ATT_CEF_LINK_ATTRIBUTE_NAME);
	
    if ( user != null ) {
//		System.out.println("CEFActivityCorrelation: Matching for user " + user);
        returnMap.put("linkAttributeName", cefLinkAttributeName);
        returnMap.put("linkAttributeValue", user);
//        System.out.println("returnMap " + returnMap);
    }

    return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Application Builder">
  <Description>
    A rule to build and manipulate IdentityIQ application in a bulk.
    All duties are mentioned below.
    1. When create mode is selected, then it creates multiple application in a bulk by parsing csv file.
    2. When update mode is selected, then it updates the attribute map of existing application by parsing input csv file.
    3. When read mode is selected, then it reads all existing IdentityIQ application and export them to csv file.
       Exports considers only attributes of the application.
  </Description>
  <Signature returnType="TaskResult">
    <Inputs>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to
          query the database to save application object and task definitions.
        </Description>
      </Argument>
      <Argument name="log">
        <Description>
          The log object for logging.
        </Description>
      </Argument>
      <Argument name="inputParams">
        <Description>
          The input params object is map of attributes received from Task UI.
        </Description>
      </Argument>
      <Argument name="taskResult">
        <Description>
          The task result object required for updating the result.
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
    
      import java.io.BufferedReader;
      import java.io.FileNotFoundException;
      import java.io.FileReader;
      import java.io.IOException;
      import java.util.ArrayList;
      import java.util.Date;
      import java.util.HashMap;
      import java.util.LinkedHashMap;
      import java.util.List;
      import java.util.Map;
      import sailpoint.api.SailPointContext;
      import sailpoint.api.TaskManager;
      import sailpoint.connector.Connector;
      import sailpoint.connector.ConnectorFactory;
      import sailpoint.connector.DefaultApplicationFactory;
      import sailpoint.object.Application;
      import sailpoint.object.Attributes;
      import sailpoint.object.Identity;
      import sailpoint.object.Rule;
      import sailpoint.object.TaskDefinition;
      import sailpoint.object.TaskItemDefinition;
      import sailpoint.object.TaskSchedule;
      import sailpoint.tools.GeneralException;
      import sailpoint.tools.Message;
      import sailpoint.tools.Util;
      import java.io.FileWriter;
      import sailpoint.object.TaskResult;
      import sailpoint.object.Filter;
      import sailpoint.object.QueryOptions;
      import sailpoint.object.Attributes;
      import java.util.Set;
      import java.util.Iterator;
      import java.util.LinkedHashMap;
      import java.util.LinkedHashSet;

      // Private member variables
      private int applicationsCreated = 0;
      private int applicationsUpdated = 0;
      private int applicationsScanned = 0;
      private List applicationsExists = new ArrayList();
      private List applicationsNotFound = new ArrayList();
      private List applicationsFailed = new ArrayList();
      Map applicationMap = new LinkedHashMap();
      Set uniqueHeaders = new LinkedHashSet();

      // Private Input parameters
      private String filePath;
      private String applicationType;
      private String operation;
      private boolean triggerAccountAggregation;
      private boolean triggerGroupAggregation;
      private boolean skipTestConnection;
      private String launcher;
      private int applicationsPerAggregation = 10;

      // Public member variables
      /**
      * List of secret attributes used in different connector's application attribute.
      */
      Set secreteAttributes = new LinkedHashSet();
      String rowSeparator = "\n";

      /////////// public methods for processing IdentityIQ applications. ///////////
      //////////////////////////////////////////////////////////////////////////////

      /**
       * Parse the input CSV file based on fix format.
       * and convert it to the attribute map for further processing.
       */
      public void parseInputFile() {
          if (log.isDebugEnabled()) {
              log.debug("Entering parseInputFile()...");
          }

          BufferedReader br = null;

          try {
              String fileRow = "";
              List fileHeaders = new ArrayList();
              Map attributeMap = null;
              br = new BufferedReader(new FileReader(filePath));

              // Parse file headers
              if ((fileRow = br.readLine()) != null) {
                  if (log.isDebugEnabled()) {
                      log.debug("File headers: " + fileRow);
                  }
                  fileHeaders = Util.csvToList(fileRow);
              }

              // Parse CSV file data
              while ((fileRow = br.readLine()) != null) {
                  List fileRowList = Util.csvToList(fileRow);
                  attributeMap = new HashMap();
                  boolean isApplicationName = true;
                  String applicationName = "";
                  int i = 1;

                  // Attribute Map received from input file
                  for (Object dataObj : fileRowList) {
                      if (dataObj != null) {
                          String fileRowData = (String)dataObj;
                          if (isApplicationName) {
                              applicationName = fileRowData;
                              isApplicationName = false;
                          } else {
                              if (fileRowData.equalsIgnoreCase("true") || fileRowData.equalsIgnoreCase("false")) {
                                  attributeMap.put(fileHeaders.get(i), Boolean.parseBoolean(fileRowData));
                              } else {
                                  attributeMap.put(fileHeaders.get(i), fileRowData);
                              }
                              i++;
                          }
                      }
                  }
                  applicationMap.put(applicationName, attributeMap);
              }
          } catch (FileNotFoundException e) {
              throw new GeneralException("File parsing failed. " + e.getMessage(), e);
          } catch (IOException e) {
              throw new GeneralException("File parsing failed. " + e.getMessage(), e);
          } finally {
              try {
                  if (br != null) {
                      br.close();
                  }
              } catch (Exception ex) {
                  if (log.isWarnEnabled()) {
                      log.warn("Error while closing BufferedReader object. " + ex.getMessage);
                  }
              }
          }

          if (log.isDebugEnabled()) {
              log.debug("Exiting parseInputFile()...");
          }
      }

      /**
       * Create multiple IdentityIQ applications based on input application data.
       */
      private void createApplications() {
          if (log.isDebugEnabled()) {
              log.debug("Entering createApplications()...");
          }

          List aggregationappList = new ArrayList();

          for (Map.Entry entry : applicationMap.entrySet()) {
              String applicationName = (String) entry.getKey();
              Application application = context.getObjectByName(Application.class, applicationName);
              if (application != null) {
                  if (log.isWarnEnabled()) {
                      log.warn("The application '" + applicationName +"' is already exits on the IdentityIQ server.");
                  }
                  applicationsExists.add(applicationName);
                  continue;
              }

              // Create new IdentityIQ application
              if (log.isDebugEnabled()) {
                  log.debug("Creating the application: " + applicationName);
              }
              application = DefaultApplicationFactory.getDefaultApplicationByTemplate(applicationType);
              application.setCreated(new Date());
              application.setModified(new Date());
              application.setName(entry.getKey());
              application.setAuthoritative(false);
              application.setCaseInsensitive(true);
              application.setIcon("enterpriseIcon");
              application.setOwner(context.getObjectByName(Identity.class, launcher));

              // Update attribute map
              Map innerMap = (Map) entry.getValue();

              for (Map.Entry entryMap : innerMap.entrySet()) {
                  application.setAttribute((String)entryMap.getKey(), entryMap.getValue());
              }

              try {

                  // Skip the test connection if the flag is true
                  if (!skipTestConnection) {
                      Connector conn = ConnectorFactory.getConnector(application, null);
                      conn.testConfiguration();
                      if (log.isDebugEnabled()) {
                          log.debug("Test connection is successful for the application: " + applicationName);
                      }
                  } else {
                      if (log.isDebugEnabled()) {
                          log.debug("Skipping Test connection for the application: " + applicationName);
                      }
                  }
                  context.saveObject(application);
                  context.commitTransaction();

                  if (log.isDebugEnabled()) {
                      log.debug("Created the application: " + applicationName);
                  }
                  applicationsCreated++;

                  aggregationappList.add(application.getName());

                  // Perform account and group aggregation task for configured applications per aggregation
                  if (aggregationappList.size() == applicationsPerAggregation) {
                      // Trigger account aggregation
                      if (triggerAccountAggregation) {
                          executeAccountAggregation(Util.listToCsv(aggregationappList));
                      }

                      // Trigger group aggregation
                      if (triggerGroupAggregation) {
                          executeGroupAggregation(Util.listToCsv(aggregationappList));
                      }
                      aggregationappList.clear();
                  }
              } catch (Exception ex) {
                  applicationsFailed.add(application.getName());
                  if (log.isErrorEnabled()) {
                      log.error("Failed to create the application '" + applicationName + "'. " + ex.getMessage(), ex);
                  }
                  continue;
              }
          }

          // Perform account and group aggregation for remianing applications
          if (!aggregationappList.isEmpty()) { 
              if (triggerAccountAggregation) {
                  executeAccountAggregation(Util.listToCsv(aggregationappList));
              }

              if (triggerGroupAggregation) {
                  executeGroupAggregation(Util.listToCsv(aggregationappList));
              }
          }

          // Update the TaskResult object
          if (applicationsFailed.size() &gt; 0) {
              taskResult.setCompletionStatus(TaskResult.CompletionStatus.Error);
              taskResult.addMessage(Message.error("application_builder_create_failed_error", applicationsFailed.size()));
          } else if (applicationsExists.size() &gt; 0) {
              taskResult.setCompletionStatus(TaskResult.CompletionStatus.Warning);
              taskResult.addMessage(Message.warn("application_builder_create_warning_msg", filePath));
          } else {
              taskResult.setCompletionStatus(TaskResult.CompletionStatus.Success);
          }

          taskResult.setInt("applicationsCreated", applicationsCreated);
          taskResult.setAttribute("applicationsFailed", Util.listToCsv(applicationsFailed));
          taskResult.setAttribute("applicationsExists", Util.listToCsv(applicationsExists));

          if (log.isDebugEnabled()) {
              log.debug("Exiting createApplications()...");
          }
      }

      /**
       * Update multiple IdentityIQ applications based on input application data.
       */
      private void updateApplications() {
          if (log.isDebugEnabled()) {
              log.debug("Entering updateApplications()...");
          }

          List aggregationappList = new ArrayList();

          for (Map.Entry entry : applicationMap.entrySet()) {
              String applicationName = (String) entry.getKey();
              Application application = context.getObjectByName(Application.class, applicationName);
              if (application == null) {
                  if (log.isWarnEnabled()) {
                      log.warn("The application '" + applicationName + "' is not found.");
                  }
                  applicationsNotFound.add(applicationName);
                  continue;
              }

              // Update existing IdentityIQ application
              if (log.isDebugEnabled()) {
                  log.debug("Updating the application: " + applicationName);
              }

              // Update attribute map
              Map innerMap = (Map) entry.getValue();

              for (Map.Entry entryMap : innerMap.entrySet()) {
                  application.setAttribute((String)entryMap.getKey(), entryMap.getValue());
              }

              try {

                  // Skip the test connection if the flag is true
                  if (!skipTestConnection) {
                      Connector conn = ConnectorFactory.getConnector(application, null);
                      conn.testConfiguration();
                      if (log.isDebugEnabled()) {
                          log.debug("Test connection is successful for the application: " + applicationName);
                      }
                  } else {
                      if (log.isDebugEnabled()) {
                          log.debug("Skipping Test connection for the application: " + applicationName);
                      }
                  }
                  context.saveObject(application);
                  context.commitTransaction();

                  if (log.isDebugEnabled()) {
                      log.debug("Updated the application: " + applicationName);
                  }
                  applicationsUpdated++;

                  aggregationappList.add(application.getName());

                  // Perform account and group aggregation task for configured applications per aggregation
                  if (aggregationappList.size() == applicationsPerAggregation) {
                      // Trigger account aggregation
                      if (triggerAccountAggregation) {
                          executeAccountAggregation(Util.listToCsv(aggregationappList));
                      }

                      // Trigger group aggregation
                      if (triggerGroupAggregation) {
                          executeGroupAggregation(Util.listToCsv(aggregationappList));
                      }
                      aggregationappList.clear();
                  }
              } catch (Exception ex) {
                  applicationsFailed.add(application.getName());
                  if (log.isErrorEnabled()) {
                      log.error("Failed to update the application '" + applicationName + "'. " + ex.getMessage(), ex);
                  }
                  continue;
              }
          }

          // Perform account and group aggregation for remianing applications
          if (!aggregationappList.isEmpty()) {
              if (triggerAccountAggregation) {
                  executeAccountAggregation(Util.listToCsv(aggregationappList));
              }

              if (triggerGroupAggregation) {
                  executeGroupAggregation(Util.listToCsv(aggregationappList));
              }
          }

          // Update the TaskResult object
          if (applicationsFailed.size() &gt; 0) {
              taskResult.setCompletionStatus(TaskResult.CompletionStatus.Error);
              taskResult.addMessage(Message.error("application_builder_update_failed_error", applicationsFailed.size()));
          } else if (applicationsNotFound.size() &gt; 0) {
              taskResult.setCompletionStatus(TaskResult.CompletionStatus.Warning);
              taskResult.addMessage(Message.warn("application_builder_update_warning_msg", filePath));
          } else {
              taskResult.setCompletionStatus(TaskResult.CompletionStatus.Success);
          }

          taskResult.setInt("applicationsUpdated", applicationsUpdated);
          taskResult.setAttribute("applicationsFailed", Util.listToCsv(applicationsFailed));
          taskResult.setAttribute("applicationsNotFound", Util.listToCsv(applicationsNotFound));

          if (log.isDebugEnabled()) {
              log.debug("Exiting updateApplications()...");
          }
      }

      /**
       * Retriving the application object from IdentityIQ database for given application type and
       * updating the applicationMap which will be exported to csv file.
       */
      public void updateAttributesMap() {
          if (log.isDebugEnabled()) {
              log.debug("Entering updateAttributesMap()...");
          }

          try {
              Map attributeMap = null;
              boolean encryptedAttrFound = false;

              // Query filter to get list of applications for the specified application type
              Filter filter = Filter.eq("type", applicationType);

              // List of application objects
              List applicationsObjectList = context.getObjects(Application.class, new QueryOptions().addFilter(filter));

              for (Application application : applicationsObjectList) {
                  if (log.isDebugEnabled()) {
                      log.debug("Applcation name: " + application.getName());
                  }

                  uniqueHeaders.add("Name");
                  attributeMap = new HashMap();
                  applicationMap.put(application.getName(), attributeMap);
                  attributeMap.put("Name", application.getName());
                  Attributes attrMap = application.getAttributes();

                  // Update encrypted attribute
                  if (!encryptedAttrFound) {
                      if (attrMap.get("encrypted") != null) {
                          List encryptedAttrs = Util.csvToList(attrMap.get("encrypted").toString());
                          secreteAttributes.addAll(encryptedAttrs);
                          encryptedAttrFound = true;
                      }
                  }

                  for (Map.Entry entry : attrMap.entrySet()) {
                      if (entry.getValue() != null) {
                          if (entry.getValue() instanceof String || entry.getValue() instanceof Boolean) {

                              // Update attribute map with key and value
                              attributeMap.put(entry.getKey().toString(), entry.getValue());

                              // Update header set
                              uniqueHeaders.add(entry.getKey().toString());
                          }
                      }
                  }
              }
          } catch (Exception e) {
              throw new GeneralException("Failed to retrieve application attributes map. " + e.getMessage(), e);
          }

          if (log.isDebugEnabled()) {
              log.debug("Entering updateAttributesMap()...");
          }
      }

      /**
      * Export Applications attribute map in csv format.
      */
      public void exportApplications() {
          if (log.isDebugEnabled()) {
              log.debug("Entering exportApplications()...");
          }

          FileWriter fileWriter = null;

          if (Util.isEmpty(applicationMap)) {
              if (log.isWarnEnabled()) {
                  log.warn("Application '" + applicationType + "' not found on the IdentityIQ server.");
              }
              taskResult.setCompletionStatus(TaskResult.CompletionStatus.Success);
              taskResult.setAttribute("applicationsScanned", applicationMap.size());
          } else {
              // Perform the file operation when application map is non empty.
              try {
                  fileWriter = new FileWriter(filePath);
                  fileWriter.append(Util.listToCsv(new ArrayList(uniqueHeaders)));
                  fileWriter.append(rowSeparator);

                  for (Map.Entry entry : applicationMap.entrySet()) {
                      StringBuffer attributeRow = new StringBuffer();
                      Map innerAttrMap = (Map) entry.getValue();
                      for (Iterator iterator = uniqueHeaders.iterator(); iterator.hasNext();) {
                          String headerName = (String) iterator.next();
                          String attrValue = (innerAttrMap.get(headerName) != null) ? innerAttrMap.get(headerName).toString() : "NULL";
                          if (secreteAttributes.contains(headerName)) {
                              attrValue = "NULL";
                          } else if (attrValue.contains(",")) {
                              attrValue = "\"" + innerAttrMap.get(headerName).toString() + "\"";
                          }

                          // prepare CSV file row
                          if (attributeRow.length() == 0) {
                              attributeRow.append(attrValue);
                          } else {
                              attributeRow.append("," + attrValue);
                          }
                      }

                      // Update File Row
                      fileWriter.append(attributeRow);
                      fileWriter.append(rowSeparator);
                  }
              } catch (Exception e) {
                  throw new GeneralException("Failed to export the application attributes map to a file. " + e.getMessage(), e);
              } finally {
                  try {
                      if (fileWriter != null) {
                          fileWriter.flush();
                          fileWriter.close();
                      }
                  } catch (Exception ex) {
                      if (log.isWarnEnabled()) {
                          log.warn("Error while closing fileWriter object. " + ex.getMessage);
                      }
                  }
              }

              taskResult.setCompletionStatus(TaskResult.CompletionStatus.Success);
              taskResult.setAttribute("applicationsScanned", applicationMap.size());
              taskResult.setAttribute("exportFilePath", filePath);
          }

          if (log.isDebugEnabled()) {
              log.debug("Exiting exportApplications()...");
          }
      }

      /**
       * Run Account aggregation task for the multiple IdentityIQ applications
       * @param applicationNames comma saperated application names
       * 
      */
      private void executeAccountAggregation(String applicationNames) throws GeneralException {
          if (log.isDebugEnabled()) {
              log.debug("Entering executeAccountAggregation()...");
          }

          TaskManager tm = new TaskManager(context);
          HashMap taskArgs = new HashMap();
          TaskDefinition taskDefinition = new TaskDefinition();
          taskDefinition.setName(applicationType + " Account Aggregation " + new Date());
          taskDefinition.setDescription("Account Aggregation task for " + applicationType);
          taskDefinition.setType(TaskItemDefinition.Type.AccountAggregation);
          taskDefinition.setResultAction(TaskDefinition.ResultAction.Delete);
          taskDefinition.setFormPath("/monitor/tasks/accountAggregationTask.xhtml");
          taskDefinition.setArgument("applications", applicationNames);
          taskDefinition.setArgument("checkDeleted", "true");
          taskDefinition.setArgument("promoteManagedAttributes", "true");
          taskDefinition.setArgument("logAllowedActions", null);
          taskDefinition.setOwner(context.getObjectByName(Identity.class, launcher));
          taskDefinition.setParent(context.getObject(TaskDefinition.class, "Account Aggregation"));
          context.saveObject(taskDefinition);
          context.commitTransaction();
          tm.runWithResult(taskDefinition, taskArgs);

          if (log.isDebugEnabled()) {
              log.debug("Account aggregation task is executed for the application '" + applicationNames + "'.");
              log.debug("Exiting executeAccountAggregation()...");
          }
      }

      /**
       * Run Group aggregation task for the multiple IdentityIQ applications
       * applicationNames comma saperated application names
      */
      private void executeGroupAggregation(String applicationNames) throws GeneralException {
          if (log.isDebugEnabled()) {
              log.debug("Entering executeGroupAggregation()...");
          }

          TaskManager tm = new TaskManager(context);
          HashMap taskArgs = new HashMap();
          TaskDefinition taskDefinition = new TaskDefinition();
          taskDefinition.setName(applicationType + " Group Aggregation " + new Date());
          taskDefinition.setDescription("Group Aggregation task for " + applicationType);
          taskDefinition.setType(TaskItemDefinition.Type.AccountGroupAggregation);
          taskDefinition.setArgument("aggregationType", "group");
          taskDefinition.setFormPath("/monitor/tasks/accountGroupAggregationTask.xhtml");
          taskDefinition.setArgument("applications", applicationNames);
          taskDefinition.setArgument("checkDeleted", "true");
          taskDefinition.setOwner(context.getObjectByName(Identity.class, launcher));
          taskDefinition.setExecutor("sailpoint.task.ResourceIdentityScan");
          taskDefinition.setResultRenderer("accountGroupAggregationResult.xhtml"); 
          taskDefinition.setParent(context.getObject(TaskDefinition.class, "Account Group Aggregation"));
          context.saveObject(taskDefinition);
          context.commitTransaction();
          tm.runWithResult(taskDefinition, taskArgs);

          if (log.isDebugEnabled()) {
              log.debug("Group aggregation task is executed for the application '" + applicationNames + "'.");
              log.debug("Exiting executeGroupAggregation()...");
          }
      }

      /////////////////// MAIN START /////////////////
      ////////////////////////////////////////////////


      if (log.isDebugEnabled()) {
          log.debug("Application Builder Rule execution start...");
      }

      try {
          // Retriving input parameters
          filePath = inputParams.get("filePath");
          applicationType = inputParams.get("applicationType");
          operation = inputParams.get("operation");
          triggerAccountAggregation = inputParams.get("triggerAccountAggregation");
          triggerGroupAggregation = inputParams.get("triggerGroupAggregation");
          launcher = inputParams.get("launcher");
          skipTestConnection = inputParams.get("skipTestConnection");

          if (!filePath.endsWith(".csv")) {
              throw new GeneralException("Invalid input file format '" + filePath + "'. Only CSV format is supported.");
          }

          if (inputParams.get("applicationsPerAggregation") != null) {
              try {
                  if (Integer.parseInt(inputParams.get("applicationsPerAggregation")) &gt; 0) {
                      applicationsPerAggregation = Integer.parseInt(inputParams.get("applicationsPerAggregation"));
                  }
              } catch (NumberFormatException e) {
                  if (log.isWarnEnabled()) {
                      log.warn("Invalid value for the attribute 'applicationsPerAggregation'. " + e.getMessage() + ". Considering default value " + applicationsPerAggregation , e);
                  }
              }
          }

          // Update Secrete attribute list as per sailpoint.object.Application 
          secreteAttributes.add("password");
          secreteAttributes.add("cmdClientPassword");
          secreteAttributes.add("adminPassword");
          secreteAttributes.add("apikey");
          secreteAttributes.add("kid");
          secreteAttributes.add("secret");
          secreteAttributes.add("keystorePwd");
          secreteAttributes.add("token");
          secreteAttributes.add("transportUserPassword");
          secreteAttributes.add("group.password");
          secreteAttributes.add("accountId");
          secreteAttributes.add("keystorepassword");
          secreteAttributes.add("pkeypassword");
          secreteAttributes.add("admin_password");
          secreteAttributes.add("SudoUserPassword");
          secreteAttributes.add("PassphraseForPrivateKey");
          secreteAttributes.add("passwd");

          // Perform Task based on operation type
          switch (operation) {
              case "create":
                  parseInputFile();
                  createApplications();
                  break;
              case "update":
                  parseInputFile();
                  updateApplications();
                  break;
              case "read":
                  updateAttributesMap();
                  exportApplications();
                  break;
              default:
                  log.debug("Invalid Operation.");
                  break;
          }
      } catch (GeneralException e) {
          if (log.isErrorEnabled()) {
              log.error(Message.error("application_builder_task_error", e.getMessage()), e);
          }

          // Update taskResult object with error details
          taskResult.setCompletionStatus(TaskResult.CompletionStatus.Error);
          taskResult.addMessage(Message.error("application_builder_task_error", e.getMessage()));
      } catch (Exception e) {
          GeneralException ex = new GeneralException(Message.error("application_builder_task_error", e.getMessage()), e);
          if (log.isErrorEnabled()) {
              log.error(ex.getMessage(), ex);
          }

          // Update taskResult object with error details
          taskResult.setCompletionStatus(TaskResult.CompletionStatus.Error);
          taskResult.addMessage(Message.error("application_builder_task_error", e.getMessage()));
      }

      return taskResult;
    
  </Source>
</Rule>
<Rule language="beanshell" name="Creation Rule - Set Password" type="IdentityCreation">
  <Description>Identity creation rules are used to set attributes on new Identity objects when they are created.  New identities may be created during the aggregation of application accounts, or optionally created after pass-through authentication.

One common operation is to change the name property of the identity when the default application name is complex (such as a directory DN).

Another common operation is to assign a set of initial capabilities based on the attributes pulled from the application account.</Description>
  <Signature returnType="void">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="environment" type="Map">
        <Description>
          Arguments passed to the aggregation task.
        </Description>
      </Argument>
      <Argument name="application">
        <Description>
          Application being aggregated.
        </Description>
      </Argument>
      <Argument name="account" type="ResourceObject">
        <Description>
          The resource account for the identity being created.
        </Description>
      </Argument>
      <Argument name="identity" type="Identity">
        <Description>
          The identity that is being created.
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>import sailpoint.object.Identity;

    // All identities using this creation rule will have their passwords set to "xyzzy"

identity.setPassword("xyzzy");


</Source>
</Rule>
<Rule language="beanshell" name="PRISM - Correlation" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="environment" type="Map">
        <Description>
          Arguments passed to the aggregation task.
        </Description>
      </Argument>
      <Argument name="application">
        <Description>
          Application being aggregated.
        </Description>
      </Argument>
      <Argument name="account">
        <Description>
          A sailpoint.object.ResourceObject returned from the
          collector.
        </Description>
      </Argument>
      <Argument name="link">
        <Description>
          Existing link to this account.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="identityName">
        <Description>
          The name of an Identity object.
        </Description>
      </Argument>
      <Argument name="identity">
        <Description>
          A fully resolved Identity object if the rule wants
          to do its own queries to locate the identity.
        </Description>
      </Argument>
      <Argument name="identityAttributeName">
        <Description>
          The name of the extended attribute that can be used
          to locate an existing identity.
        </Description>
      </Argument>
      <Argument name="identityAttributeValue">
        <Description>
          The value of the named extended attribute that can be used
          to locate an existing identity. This attribute is used
          together with the identityAttributeName argument.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import java.lang.String;
import java.util.*; 
import sailpoint.object.*; 

// Try to correlate first on Login name
// If that doesn't work try lower case "first initial" plus lower case "last name" 

String login = account.getAttribute("login"); 
System.out.println("Trying to correlation PRISM account: " + login); 

Identity cube = (Identity) context.getObjectByName(Identity.class,login); 
if (null != cube) {
   // found cube
  if (cube.isCorrelated()) {
       System.out.println("Successful Correlation based on login:" + login); 
       return   java.util.Collections.singletonMap("identity", (Object) cube);
   }
} else {

     // try to add First to Last with a "." in the middle

     login = account.getAttribute("first") + "." +  account.getAttribute("last");
     System.out.println("Trying to Correlate based on new login:" + login); 

     cube = (Identity) context.getObjectByName(Identity.class,login);  
     if (null != cube) {
            // found cube
            if (cube.isCorrelated()) {
                  System.out.println("Successful Correlation based on newly calculated login:" + login); 
                  return  java.util.Collections.singletonMap("identity", (Object) cube);
             }
     }
}

// Nothing to correlate to
return  new HashMap(); </Source>
</Rule>
<Rule language="beanshell" name="PRISM - Provision" type="JDBCProvision">
  <Description>A Provisioning rule for the PRISM application. Handles Account Creates/Deletes/Modifies/Unlocks/Enables/Disables</Description>
  <Signature returnType="ProvisioningResult">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="application">
        <Description>
                The application whose data file is being processed.
                </Description>
      </Argument>
      <Argument name="schema">
        <Description>
                The Schema currently in use.
                </Description>
      </Argument>
      <Argument name="connection">
        <Description>
                A connection object to connect to database.
                </Description>
      </Argument>
      <Argument name="plan">
        <Description>
                The ProvisioningPlan created against the logical application.
                </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="result">
        <Description>
                A Provisioning Result object is desirable to return the status.IT can be a new object or part of  Provisioning Plan
                </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
import java.util.Date;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.SQLException;
import java.sql.ResultSet;
import java.sql.Types;
import java.util.List;
import sailpoint.api.SailPointContext;
import sailpoint.connector.JDBCConnector;
import sailpoint.object.Application;
import sailpoint.object.ProvisioningPlan;
import sailpoint.object.ProvisioningPlan.AccountRequest;
import sailpoint.object.ProvisioningPlan.AttributeRequest;
import sailpoint.object.ProvisioningPlan.PermissionRequest;
import sailpoint.object.ProvisioningResult;
import sailpoint.object.Schema;
import sailpoint.tools.xml.XMLObjectFactory;
import org.apache.commons.logging.LogFactory;
import org.apache.commons.logging.Log;
import sailpoint.tools.Util;

		//
		// Internal method for grabbing an Attribute Request Value.
		//
		
	   public Object getAttributeRequestValue(AccountRequest acctReq, String attribute) {
	    	if ( acctReq != null ) {
	    	  AttributeRequest attrReq = acctReq.getAttributeRequest(attribute);
	    	  if ( attrReq != null ) {
	    	    return attrReq.getValue();
	    	  }
	    	}
	    	return null;
	    }

//
// JDBC Provisioning Rule Body
//
// We will handle these cases right now: 
// 
// Account Request Create
// Account Request Modify
// Account Request Delete
// Account Lock/Unlock
// Account Enable/Disable
//
	
Date now = new Date();

System.out.println("\n\n\n\n\n");
System.out.println("****************************************");
System.out.println("Entering Provisioning Rule for PRISM");
System.out.println(" Current Time =  " + now.toString());
System.out.println("****************************************");


//
// The ProvisioningResult is the return object for this type of rule. We'll create it here and then populate it later
//

ProvisioningResult result = new ProvisioningResult();


//
// Check if the plan is null or not, if not null, process it... 
//

if ( plan != null ) {

	System.out.println("*** \n The Provisioning Plan being passed in = \n***\n" + plan.toXml() + "\n****************************************");

	List accounts = plan.getAccountRequests();
	
	// 
	//  Get all Account Requests out of the plan
	// 

	if ( ( accounts != null ) &amp;&amp; ( accounts.size() &gt; 0 ) ) {
	
		//
		// If the plan contains one or more account requests, we'll iterate through them
		//
		
		for ( AccountRequest account : accounts ) {
			
			try {
			
				// 
				// All of the account operations will reside in a try block in case we have any errors, we can mark the provisioningresult as "Failed" if we have an issue.
				//

				if (AccountRequest.Operation.Create.equals(account.getOperation())) {

					//
					// CREATE Operation
					// 				
				
					System.out.println("Account Request Operation = Create");

					PreparedStatement statement = connection.prepareStatement("insert into users (login,first,last,groups,status,locked) values (?,?,?,?,?,?)");
					statement.setString(1, (String) account.getNativeIdentity());
					statement.setString(2, getAttributeRequestValue(account, "first"));
					statement.setString(3, getAttributeRequestValue(account, "last"));
					statement.setString(5, getAttributeRequestValue(account, "status"));
					statement.setString(6, getAttributeRequestValue(account, "locked"));
					 //
					 // Grab the role from the request. If it's a single role, it'll be a string, add it to 
					 // the statement, other wise if it's a List, convert to CSV and add it to the statement
					 //
					 AttributeRequest attrReq = account.getAttributeRequest("groups");
					 if (attrReq != null) {
								if (attrReq.getValue() instanceof String) {
									statement.setString(4, (String) attrReq.getValue());
								} else if (attrReq.getValue() instanceof List) {
									String listOfRoles = Util.listToCsv((List) attrReq.getValue());
									statement.setString(4, listOfRoles);
								}
					 } else {
                                                               statement.setString(4,"");
                                         }

					System.out.println("Preparing to execute: " + statement);
					statement.executeUpdate();
						
					//
					// Sucessful Create, so mark result as COMMITTED
					//
					
					result.setStatus(ProvisioningResult.STATUS_COMMITTED);
					

				} else if (AccountRequest.Operation.Modify.equals(account.getOperation())) {
				
					//
					// MODIFY Operation
					// 
				
					//
					// We have a modify, this one is trickier, as we can have "Add" and "Remove" 
					// operations and each can be a single string value or a list
					//

					System.out.println("Account Request Operation = Modify");

					//
					// Determine what the current roles are first... 
					//

					Statement curr_stmt = connection.createStatement();
					ResultSet rs = curr_stmt .executeQuery("select * from users where login = '" + account.getNativeIdentity() + "'");

					//
					//  Check result set. Should only be one row since login is a unique key for the table
					//
					List current_roles = null;
					String roles = "";

					while (rs.next()) {
					   roles = roles + "," + rs.getString("groups");
					} 
					current_roles = Util.csvToList(roles,true);
					
					if (current_roles == null) {
						System.out.println("We have a null current_roles list... change it to an empty list for subsequent processing.");
						current_roles = new ArrayList();
					}

					System.out.println("Current Roles for User = " + Util.listToCsv(current_roles));

					//
					// Get all Attribute Requests and pull out just the role ones. 
					//
										
					List remove_roles = new ArrayList();
					List add_roles = new ArrayList(); 
					//
					// Get all attribute requests and then we will filter for those related to the roles column
					//
					List mod_attr_requests = account.getAttributeRequests();
							
					if (mod_attr_requests != null) {
						for (AttributeRequest req : mod_attr_requests ) {
								if (req.getName().equals("groups")) {
								   if (ProvisioningPlan.Operation.Remove.equals(req.getOperation())) {
										// Process Removes First
										if (req.getValue() instanceof String) {
												  remove_roles = Util.csvToList(req.getValue());
										} else if (req.getValue() instanceof List) {
												  remove_roles = req.getValue();                
										}
									} else if (ProvisioningPlan.Operation.Add.equals(req.getOperation())) {
										// Process Adds Second
										if (req.getValue() instanceof String) {
												   add_roles = Util.csvToList(req.getValue());
										} else if (req.getValue() instanceof List) {
												  add_roles = req.getValue();                     
										}
									} 

							   } 
						}
					}
					//
					//  We now have a calculated list of the roles we are adding, the roles we are removing, and the current roles for the user.
					//
					System.out.println("Add Roles = " + Util.listToCsv(add_roles));
					System.out.println("Remove Roles = " + Util.listToCsv(remove_roles));


					//
					// If we have roles to remove, remove them
					//
					if (!remove_roles.isEmpty()) {
						System.out.println("About to remove roles: " + remove_roles.toString() + "from the current_roles = " + current_roles.toString());
						current_roles.removeAll(remove_roles);
					}
					//
					// If we have roles to add, check if they are there and add them as we iterate through
					//
					
					if (!add_roles.isEmpty()) {
						System.out.println("About to add roles: " + add_roles.toString() + " to the current_roles = " + current_roles.toString());
						for (Object item: add_roles) {
							 if (!current_roles.contains(item)) {
									   current_roles.add(item);
							 }
						}
					}
					
					//
					//  Print out the list of roles being provisioned after processing "add" and "remove" operations
					//
					System.out.println("Updating the roles for:" + (String) account.getNativeIdentity() + " Current Roles after adding/removing = " + Util.listToCsv(current_roles)); 

					//
					// Process update SQL operation
					//

					PreparedStatement statement = connection.prepareStatement("update users set groups = ? where login = ?");
					statement.setString(2, (String) account.getNativeIdentity());
					statement.setString(1,Util.listToCsv(current_roles)); 
					statement.executeUpdate();

					// Add these in the future.
					// statement.setString ( 2,
					// getAttributeRequestValue(account,"first") );
					// statement.setString ( 3,
					// getAttributeRequestValue(account,"last") );
					// statement.setString ( 4,
					// getAttributeRequestValue(account,"groups") );
					// statement.setString ( 5,
					// getAttributeRequestValue(account,"status") );

					result.setStatus(ProvisioningResult.STATUS_COMMITTED);

				} else if (AccountRequest.Operation.Delete.equals(account.getOperation())) {
				
					//
					// DELETE Operation
					// 


					System.out.println("Account Request Operation = Delete");
					PreparedStatement statement = connection.prepareStatement("delete from users where login = ?");
					statement.setString(1, (String) account.getNativeIdentity());
					statement.executeUpdate();

					result.setStatus(ProvisioningResult.STATUS_COMMITTED);

				} else if (AccountRequest.Operation.Disable.equals(account.getOperation())) {

System.out.println("Account Request Operation = Disable");
	PreparedStatement statement = connection.prepareStatement("update users set status = 'I' where login = ?");
					statement.setString(1, (String) account.getNativeIdentity());
					statement.executeUpdate();
					result.setStatus(ProvisioningResult.STATUS_COMMITTED);

				} else if (AccountRequest.Operation.Enable.equals(account.getOperation())) {

System.out.println("Account Request Operation = Enable");
	PreparedStatement statement = connection.prepareStatement("update users set status = 'A' where login = ?");
					statement.setString(1, (String) account.getNativeIdentity());
					statement.executeUpdate();
					result.setStatus(ProvisioningResult.STATUS_COMMITTED);


				} else if (AccountRequest.Operation.Lock.equals(account.getOperation())) {

System.out.println("Account Request Operation = Lock");
	PreparedStatement statement = connection.prepareStatement("update users set locked = 'Y' where login = ?");
					statement.setString(1, (String) account.getNativeIdentity());
					statement.executeUpdate();
					result.setStatus(ProvisioningResult.STATUS_COMMITTED);


				} else if (AccountRequest.Operation.Unlock.equals(account.getOperation())) {

System.out.println("Account Request Operation = Unlock");
	PreparedStatement statement = connection.prepareStatement("update users set locked = 'N' where login = ?");
					statement.setString(1, (String) account.getNativeIdentity());
					statement.executeUpdate();
					result.setStatus(ProvisioningResult.STATUS_COMMITTED);

				} else {

					// Unknown operation!
					System.out.println("Unknown operation ["
							+ account.getOperation() + "]!");
				}

			} catch (SQLException e) {
                        System.out.println("Error: " + e);
                        result.setStatus(ProvisioningResult.STATUS_FAILED);
                        result.addError(e);
			} 
		}    // account request loop
	}     // if account requests exist
}   // if plan not null


System.out.println("****************************************");
System.out.println("****************************************");
System.out.println("Exiting Provisioning Rule for PRISM. \n  Result=  \n" + result.toXml(false));
System.out.println("****************************************");
System.out.println("****************************************");
System.out.println("\n\n\n\n\n");
		
return result;		
</Source>
</Rule>
<Rule language="beanshell" name="PRISM - BuildMap" type="JDBCBuildMap">
  <Description>This rule is used by the JDBC connector to build a map representation of the Resultset.</Description>
  <Signature returnType="Map">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="application">
        <Description>
                The application whose data file is being processed.
                </Description>
      </Argument>
      <Argument name="schema">
        <Description>
                The Schema currently in use.
                </Description>
      </Argument>
      <Argument name="state">
        <Description>
                A Map containing state information.
                </Description>
      </Argument>
      <Argument name="result">
        <Description>
                The ResultSet from database.
                </Description>
      </Argument>
      <Argument name="connection">
        <Description>
                A connection object to connect to database.
                </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="map">
        <Description>
                A Map of the resource object assembled from the data.
                </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import sailpoint.connector.JDBCConnector;
import sailpoint.connector.Connector;
import java.util.HashMap;



		HashMap map = JDBCConnector.buildMapFromResultSet(result);                  

		if ( schema.getObjectType().compareTo( Connector.TYPE_ACCOUNT ) == 0 ) {

			String active = map.get("status");
                        if (active.equals("A")) {
				map.put( "IIQDisabled", false);
                        } else {
                                map.put("IIQDisabled", true); 
                        } 

			String locked = map.get("locked");
                        if (locked.equals("N")) {
				map.put( "IIQLocked", false);
                        } else {
                                map.put("IIQLocked", true); 
                        } 
				
		} else if ( schema.getObjectType().compareTo( Connector.TYPE_GROUP ) == 0 ) {              

			// Handle Groups here... 
		}                               

return map;</Source>
</Rule>
<Rule language="beanshell" name="ServiceNowServiceIntegration" type="Integration">
  <Description>
		Use this rule to customize the data loaded into the Provisioning Plan object.
		The provisioning plan and its integrationData object are used by Velocity to populate values in the XML templates for the web service calls.
	  </Description>
  <Signature returnType="Object">
    <Inputs>
      <Argument name="identity">
        <Description>
			  A sailpoint.object.Identity representing the person being remediated.
			</Description>
      </Argument>
      <Argument name="plan">
        <Description>
			  A sailpoint.object.ProvisioningPlan representing remediation.
			</Description>
      </Argument>
      <Argument name="integration">
        <Description>
			  A sailpoint.object.IntegrationConfig representing configuration object.
			</Description>
      </Argument>
      <Argument name="context">
        <Description>
			  A sailpoint.api.SailPointContext object that can be used to query the database to find the Rule.
			</Description>
      </Argument>
      <Argument name="log">
        <Description>
			  A Log object to help report and/or debug the Rule.
			</Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
	    
	      import sailpoint.object.Identity;
	      import sailpoint.object.Link;

	      /**
	       * Fields
	       */
	      String application = "ServiceNow";
	      // Default user on ServiceNow to whom ticket will be assigned if Requester do not have account on ServiceNow
	      String defaultUserOpenedBy = "admin";
	      // Default user on ServiceNow for which ticket will be created if user do not have account on ServiceNow
	      String defaultUserRequestedFor = "admin";
	      // Identity attribute on IdentityIQ/ UserID on ServiceNow
	      String userId = "user_name";

	      /**
	       * Get ServiceNow Account name for Identity
	       */
	      private getServiceNowLink(Identity identity) {
	          if (identity == null) {
	              return null;
	          }

	          List links = identity.getLinks();
	          String linkName = null;
	          if (links != null ) {
	              for (Link link : links) {
	                  String appType = link.getApplication().getType();
	                  if (appType != null &amp;&amp; appType.equals(application)) {
	                      if(link.getAttribute(userId) != null) {
	                          String userName = link.getAttribute(userId).toString();
	                          if(userName != null) {
	                              linkName = userName;
	                              break;
	                          }
	                      }
	                  }
	              }
	          }

	          return linkName;
	      }

	      ////////////////////////////////////////////////////////////////
	      // Main
	      ////////////////////////////////////////////////////////////////
	      Map arguments = (Map)plan.getArguments();
	      List&lt;Identity&gt; requesterList = plan.getRequesters();
	      Identity requester = null;
	      if (requesterList != null) {
	          requester = requesterList.get(0);
	          requester = context.getObjectByName(Identity.class, requester.getName());
	      }
	      // Get ServiceNow Account name
	      String openedBy = getServiceNowLink(requester);
	      String requestedFor = getServiceNowLink(identity);

	      // If the user for which ticket is created has ServiceNow Account put that value
	      // else put default value 
	      if (requestedFor != null) {
	          arguments.put("requestedFor", requestedFor);
	      } else {
	          arguments.put("requestedFor", defaultUserRequestedFor);
	      }

	      // If Requetser has ServiceNow Account put that value
	      // else put default value
	      if (openedBy != null) {
	          arguments.put("openedBy", openedBy);
	      } else {
	          arguments.put("openedBy", defaultUserOpenedBy);
	      }
	    
	  </Source>
</Rule>
<Rule language="beanshell" name="Correlation Rule - TRAKK" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="environment" type="Map">
        <Description>
          Arguments passed to the aggregation task.
        </Description>
      </Argument>
      <Argument name="application">
        <Description>
          Application being aggregated.
        </Description>
      </Argument>
      <Argument name="account">
        <Description>
          A sailpoint.object.ResourceObject returned from the
          collector.
        </Description>
      </Argument>
      <Argument name="link">
        <Description>
          Existing link to this account.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="identityName">
        <Description>
          The name of an Identity object.
        </Description>
      </Argument>
      <Argument name="identity">
        <Description>
          A fully resolved Identity object if the rule wants
          to do its own queries to locate the identity.
        </Description>
      </Argument>
      <Argument name="identityAttributeName">
        <Description>
          The name of the extended attribute that can be used
          to locate an existing identity.
        </Description>
      </Argument>
      <Argument name="identityAttributeValue">
        <Description>
          The value of the named extended attribute that can be used
          to locate an existing identity. This attribute is used
          together with the identityAttributeName argument.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>Map returnMap = new HashMap ();

// The Account Object has methods to get the "id" attribute from the the schema

String userid = account.getStringAttribute("id");

if (userid != null) {

     // The IdentityAttributeName is what attribute we will search on
     // This attribute should be indexed and available on all cubes
     returnMap.put("identityAttributeName","empId");
     // The actual value of the Attribute
     returnMap.put("identityAttributeValue",userid);

}
return returnMap;

</Source>
</Rule>
<Rule language="beanshell" name="Enbridge Rule HR Events Creation"/>
<Rule language="beanshell" name="Enbridge Rule HR Events Customization Rule"/>
</sailpoint>
